{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion describes the motion of an object launched into the air, influenced only by gravitational acceleration. Let\u2019s derive the fundamental equations governing this motion. Horizontal displacement : $$ x(t) = v_0 \\cos(\\theta)t $$ Vertical displacement : $$ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 $$ Where: $$ v_0 = \\text{initial velocity} $$ \\[ \\theta = \\text{angle of projection} \\] \\[ g = \\text{gravitational acceleration} \\] \\[ t = \\text{time of flight} \\] The time of flight \\(Tx\\) (when the projectile returns to the same height) is given by: \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] The horizontal range \\(R\\) (total horizontal displacement at \\(y = 0\\) ) is: \\[ R = v_0 \\cos(\\theta) \\times T \\] \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that range depends on the square of the initial velocity, the sine of twice the projection angle, and gravitational acceleration. 2. Analysis of the Range The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, i.e., when \\(2\\theta = 90^\\circ\\) or \\(\\theta = 45^\\circ\\) . Increasing \\(v_0\\) increases the range quadratically. Higher gravitational acceleration \\(g\\) decreases the range. 3. Practical Applications This model is idealized \u2014 in real-world applications, factors like air resistance and uneven terrain alter the projectile\u2019s trajectory. Extensions include: Air resistance: Introduces drag, reducing range and altering the flight path. Uneven terrain: Changes the point where the projectile lands. Wind effects: Modify horizontal velocity. 4. Implementation We can visualize the range as a function of the projection angle using Python. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 50 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Angles in degrees and radians angles = np.linspace(0, 90, 500) theta = np.radians(angles) # Compute range R = (v0**2 * np.sin(2 * theta)) / g # Plot plt.figure(figsize=(8, 6)) plt.plot(angles, R) plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.show() 5. Discussion Limitations: - No air resistance considered. - Assumes flat terrain. - Assumes constant gravitational acceleration. Extensions: - Incorporate drag force. - Simulate uneven landing surfaces. - Model varying gravitational fields. This analysis demonstrates how varying the angle of projection impacts the range of a projectile, forming a strong basis for exploring more complex real-world motion.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object launched into the air, influenced only by gravitational acceleration. Let\u2019s derive the fundamental equations governing this motion. Horizontal displacement : $$ x(t) = v_0 \\cos(\\theta)t $$ Vertical displacement : $$ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 $$ Where: $$ v_0 = \\text{initial velocity} $$ \\[ \\theta = \\text{angle of projection} \\] \\[ g = \\text{gravitational acceleration} \\] \\[ t = \\text{time of flight} \\] The time of flight \\(Tx\\) (when the projectile returns to the same height) is given by: \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] The horizontal range \\(R\\) (total horizontal displacement at \\(y = 0\\) ) is: \\[ R = v_0 \\cos(\\theta) \\times T \\] \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that range depends on the square of the initial velocity, the sine of twice the projection angle, and gravitational acceleration.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, i.e., when \\(2\\theta = 90^\\circ\\) or \\(\\theta = 45^\\circ\\) . Increasing \\(v_0\\) increases the range quadratically. Higher gravitational acceleration \\(g\\) decreases the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model is idealized \u2014 in real-world applications, factors like air resistance and uneven terrain alter the projectile\u2019s trajectory. Extensions include: Air resistance: Introduces drag, reducing range and altering the flight path. Uneven terrain: Changes the point where the projectile lands. Wind effects: Modify horizontal velocity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"We can visualize the range as a function of the projection angle using Python. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 50 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Angles in degrees and radians angles = np.linspace(0, 90, 500) theta = np.radians(angles) # Compute range R = (v0**2 * np.sin(2 * theta)) / g # Plot plt.figure(figsize=(8, 6)) plt.plot(angles, R) plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion","text":"Limitations: - No air resistance considered. - Assumes flat terrain. - Assumes constant gravitational acceleration. Extensions: - Incorporate drag force. - Simulate uneven landing surfaces. - Model varying gravitational fields. This analysis demonstrates how varying the angle of projection impacts the range of a projectile, forming a strong basis for exploring more complex real-world motion.","title":"5. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] where: - \\(\\theta\\) = angular displacement - \\(b\\) = damping coefficient - \\(g\\) = gravitational acceleration - \\(L\\) = length of the pendulum - \\(A\\) = amplitude of the external driving force - \\(\\omega\\) = frequency of the external driving force - \\(t\\) = time For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\) The general solution of this equation involves both homogeneous (natural) and particular (forced) solutions. The system exhibits resonance when the driving frequency \\(\\omega\\) matches the system's natural frequency \\(\\sqrt{g/L}\\) . 2. Analysis of Dynamics Key parameters influencing the system\u2019s behavior: - Damping coefficient (b): Controls energy dissipation; high values lead to overdamping and slow returns to equilibrium, while low values result in underdamping and oscillations. - Driving amplitude (A): Determines the intensity of the external force; larger amplitudes lead to more significant displacement and potential chaotic motion. - Driving frequency ( \\(\\omega\\) ): Controls the rate of external driving; resonance occurs when \\(\\omega \\approx \\sqrt{g/L}\\) . As the parameters change, the system transitions from: - Periodic oscillations: Regular and predictable motion. - Quasiperiodic behavior: Motion with two incommensurate frequencies. - Chaotic motion: Sensitive dependence on initial conditions, leading to unpredictable outcomes. 3. Practical Applications Energy harvesting: Devices capturing mechanical energy from oscillations. Suspension bridges: Avoiding resonance-induced destructive oscillations. Oscillating circuits: Electrical analogs of forced damped pendulums. 4. Implementation We simulate the motion of a forced damped pendulum using Python. import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Parameters g, L = 9.81, 1.0 # Gravity and pendulum length b, A, omega = 0.5, 1.2, 2.0 # Differential equation def pendulum(t, y): theta, omega_ = y dydt = [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] return dydt # Initial conditions and time span y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 1000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angular displacement (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.show() 5. Discussion Limitations: - Assumes small-angle approximation for analytical simplicity. - Ignores air resistance and other real-world frictions. Extensions: - Include nonlinear damping. - Explore non-periodic driving forces. - Visualize phase portraits and Poincar\u00e9 sections. This analysis captures the complexity of a forced damped pendulum, bridging theory and computational exploration to reveal intricate dynamics like resonance and chaos.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] where: - \\(\\theta\\) = angular displacement - \\(b\\) = damping coefficient - \\(g\\) = gravitational acceleration - \\(L\\) = length of the pendulum - \\(A\\) = amplitude of the external driving force - \\(\\omega\\) = frequency of the external driving force - \\(t\\) = time For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\(\\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t)\\) The general solution of this equation involves both homogeneous (natural) and particular (forced) solutions. The system exhibits resonance when the driving frequency \\(\\omega\\) matches the system's natural frequency \\(\\sqrt{g/L}\\) .","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Key parameters influencing the system\u2019s behavior: - Damping coefficient (b): Controls energy dissipation; high values lead to overdamping and slow returns to equilibrium, while low values result in underdamping and oscillations. - Driving amplitude (A): Determines the intensity of the external force; larger amplitudes lead to more significant displacement and potential chaotic motion. - Driving frequency ( \\(\\omega\\) ): Controls the rate of external driving; resonance occurs when \\(\\omega \\approx \\sqrt{g/L}\\) . As the parameters change, the system transitions from: - Periodic oscillations: Regular and predictable motion. - Quasiperiodic behavior: Motion with two incommensurate frequencies. - Chaotic motion: Sensitive dependence on initial conditions, leading to unpredictable outcomes.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy harvesting: Devices capturing mechanical energy from oscillations. Suspension bridges: Avoiding resonance-induced destructive oscillations. Oscillating circuits: Electrical analogs of forced damped pendulums.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We simulate the motion of a forced damped pendulum using Python. import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt # Parameters g, L = 9.81, 1.0 # Gravity and pendulum length b, A, omega = 0.5, 1.2, 2.0 # Differential equation def pendulum(t, y): theta, omega_ = y dydt = [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] return dydt # Initial conditions and time span y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 1000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval) # Plot results plt.figure(figsize=(8, 6)) plt.plot(sol.t, sol.y[0]) plt.xlabel('Time (s)') plt.ylabel('Angular displacement (rad)') plt.title('Forced Damped Pendulum Motion') plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-discussion","text":"Limitations: - Assumes small-angle approximation for analytical simplicity. - Ignores air resistance and other real-world frictions. Extensions: - Include nonlinear damping. - Explore non-periodic driving forces. - Visualize phase portraits and Poincar\u00e9 sections. This analysis captures the complexity of a forced damped pendulum, bridging theory and computational exploration to reveal intricate dynamics like resonance and chaos.","title":"5. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Certainly! Below is a detailed explanation of Kepler's Third Law, its implications, and a Python implementation to simulate circular orbits and verify the relationship. Kepler's Third Law: Orbital Period and Orbital Radius Derivation of the Relationship Kepler's Third Law states that the square of the orbital period ( \\(T^2\\) ) of a celestial body is proportional to the cube of the semi-major axis ( \\(a^3\\) ) of its orbit. For circular orbits, the semi-major axis is simply the orbital radius ( \\(r\\) ). The law can be derived from Newton's Law of Gravitation and Centripetal Force. Consider a planet of mass \\(m\\) orbiting a star of mass \\(M\\) in a circular orbit of radius \\(r\\) . The gravitational force provides the centripetal force required for circular motion: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N} \\cdot \\text{m}^2/\\text{kg}^2\\) ), - \\(v\\) is the orbital velocity of the planet. The orbital velocity \\(v\\) can be expressed in terms of the orbital period \\(T\\) : \\[ v = \\frac{2\\pi r}{T} \\] Substituting \\(v\\) into the equation: \\[ \\frac{GMm}{r^2} = \\frac{m(2\\pi r / T)^2}{r} \\] Simplifying: \\[ \\frac{GM}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Rearranging to solve for \\(T^2\\) : \\[ ^2 = \\frac{4\\pi^2 r^3}{GM} \\] This shows that: \\[ T^2 \\propto r^3 \\] This is Kepler's Third Law. Implications for Astronomy Calculating Planetary Masses : By observing the orbital period and radius of a moon or satellite, astronomers can calculate the mass of the planet it orbits. Determining Distances : The law helps determine the distances between celestial bodies in a system. Understanding Gravitational Interactions : It provides insights into the gravitational forces governing planetary systems, binary stars, and galaxies. Real-World Examples Moon's Orbit Around Earth : Orbital radius ( \\(r\\) ): ~384,400 km Orbital period ( \\(T\\) ): ~27.3 days Using Kepler's Third Law, we can verify the relationship. Planets in the Solar System : For example, Earth's orbital radius is ~1 AU (astronomical unit), and its orbital period is ~1 year. Kepler's Third Law holds true for all planets. Python Implementation Below is a Python script to simulate circular orbits and verify Kepler's Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) M = 5.972e24 # Mass of Earth (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Orbital radii (in meters) radii = np.linspace(6.371e6, 4e8, 100) # From Earth's surface to beyond the Moon's orbit # Calculate orbital periods periods = orbital_period(radii) # Plot T^2 vs r^3 plt.figure(figsize=(10, 6)) plt.plot(radii**3, periods**2, label=\"T\u00b2 vs r\u00b3\") plt.xlabel(\"Orbital Radius\u00b3 (r\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period\u00b2 (T\u00b2) [s\u00b2]\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid() plt.legend() plt.show() # Example: Moon's orbit moon_radius = 3.844e8 # Moon's orbital radius (m) moon_period = orbital_period(moon_radius) print(f\"Calculated orbital period for the Moon: {moon_period / (24 * 3600):.2f} days\") Graphical Representation The plot generated by the script will show a linear relationship between \\(T^2\\) and \\(r^3\\) , confirming Kepler's Third Law. Extension to Elliptical Orbits For elliptical orbits, Kepler's Third Law still holds, but the semi-major axis ( \\(a\\) ) replaces the orbital radius ( \\(r\\) ): \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] This generalization allows the law to apply to all types of orbits, including highly elliptical ones. Deliverables Markdown Document : This document serves as the explanation and implementation. Python Script : The script provided simulates circular orbits and verifies Kepler's Third Law. Graphical Representation : The plot confirms the \\(T^2 \\propto r^3\\) relationship. Discussion : The relationship extends to elliptical orbits and other celestial bodies, making it a universal tool in astronomy.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"Certainly! Below is a detailed explanation of Kepler's Third Law, its implications, and a Python implementation to simulate circular orbits and verify the relationship.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-orbital-period-and-orbital-radius","text":"","title":"Kepler's Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-relationship","text":"Kepler's Third Law states that the square of the orbital period ( \\(T^2\\) ) of a celestial body is proportional to the cube of the semi-major axis ( \\(a^3\\) ) of its orbit. For circular orbits, the semi-major axis is simply the orbital radius ( \\(r\\) ). The law can be derived from Newton's Law of Gravitation and Centripetal Force. Consider a planet of mass \\(m\\) orbiting a star of mass \\(M\\) in a circular orbit of radius \\(r\\) . The gravitational force provides the centripetal force required for circular motion: \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] \\[ \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Where: - \\(G\\) is the gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{N} \\cdot \\text{m}^2/\\text{kg}^2\\) ), - \\(v\\) is the orbital velocity of the planet. The orbital velocity \\(v\\) can be expressed in terms of the orbital period \\(T\\) : \\[ v = \\frac{2\\pi r}{T} \\] Substituting \\(v\\) into the equation: \\[ \\frac{GMm}{r^2} = \\frac{m(2\\pi r / T)^2}{r} \\] Simplifying: \\[ \\frac{GM}{r^2} = \\frac{4\\pi^2 r}{T^2} \\] Rearranging to solve for \\(T^2\\) : \\[ ^2 = \\frac{4\\pi^2 r^3}{GM} \\] This shows that: \\[ T^2 \\propto r^3 \\] This is Kepler's Third Law.","title":"Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-astronomy","text":"Calculating Planetary Masses : By observing the orbital period and radius of a moon or satellite, astronomers can calculate the mass of the planet it orbits. Determining Distances : The law helps determine the distances between celestial bodies in a system. Understanding Gravitational Interactions : It provides insights into the gravitational forces governing planetary systems, binary stars, and galaxies.","title":"Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth : Orbital radius ( \\(r\\) ): ~384,400 km Orbital period ( \\(T\\) ): ~27.3 days Using Kepler's Third Law, we can verify the relationship. Planets in the Solar System : For example, Earth's orbital radius is ~1 AU (astronomical unit), and its orbital period is ~1 year. Kepler's Third Law holds true for all planets.","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-implementation","text":"Below is a Python script to simulate circular orbits and verify Kepler's Third Law. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) M = 5.972e24 # Mass of Earth (kg) # Function to calculate orbital period def orbital_period(r): return np.sqrt((4 * np.pi**2 * r**3) / (G * M)) # Orbital radii (in meters) radii = np.linspace(6.371e6, 4e8, 100) # From Earth's surface to beyond the Moon's orbit # Calculate orbital periods periods = orbital_period(radii) # Plot T^2 vs r^3 plt.figure(figsize=(10, 6)) plt.plot(radii**3, periods**2, label=\"T\u00b2 vs r\u00b3\") plt.xlabel(\"Orbital Radius\u00b3 (r\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period\u00b2 (T\u00b2) [s\u00b2]\") plt.title(\"Kepler's Third Law: T\u00b2 \u221d r\u00b3\") plt.grid() plt.legend() plt.show() # Example: Moon's orbit moon_radius = 3.844e8 # Moon's orbital radius (m) moon_period = orbital_period(moon_radius) print(f\"Calculated orbital period for the Moon: {moon_period / (24 * 3600):.2f} days\")","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-representation","text":"The plot generated by the script will show a linear relationship between \\(T^2\\) and \\(r^3\\) , confirming Kepler's Third Law.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, Kepler's Third Law still holds, but the semi-major axis ( \\(a\\) ) replaces the orbital radius ( \\(r\\) ): \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] This generalization allows the law to apply to all types of orbits, including highly elliptical ones.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables","text":"Markdown Document : This document serves as the explanation and implementation. Python Script : The script provided simulates circular orbits and verifies Kepler's Third Law. Graphical Representation : The plot confirms the \\(T^2 \\propto r^3\\) relationship. Discussion : The relationship extends to elliptical orbits and other celestial bodies, making it a universal tool in astronomy.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2: Escape Velocities and Cosmic Velocities Motivation Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel. Definitions and Physical Meaning First Cosmic Velocity (Orbital Velocity) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body. Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : The minimum speed required for an object to escape the gravitational pull of a celestial body. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location. Mathematical Derivation and Parameters First Cosmic Velocity Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Python Implementation Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) # Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate third cosmic velocity (approximation for Solar System) def third_cosmic_velocity(v2): v_esc_sun = 617500 # Escape velocity from the Sun at Earth's orbit (m/s) return np.sqrt(v2**2 + v_esc_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plot results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.2 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\") plt.show() Graphical Representation The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Importance in Space Exploration First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System. Deliverables Markdown Document : This document serves as the explanation and implementation. Python Script : The script calculates and visualizes cosmic velocities for Earth, Mars, and Jupiter. Graphical Representation : The bar chart compares the velocities for different celestial bodies. Discussion : The importance of these velocities in space exploration is highlighted.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) : The minimum speed required for an object to achieve a stable circular orbit around a celestial body. Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: \\(G\\) is the gravitational constant, \\(M\\) is the mass of the celestial body, \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : The minimum speed required for an object to escape the gravitational pull of a celestial body. Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation-and-parameters","text":"","title":"Mathematical Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) # Celestial body data (mass in kg, radius in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Function to calculate first cosmic velocity def first_cosmic_velocity(mass, radius): return np.sqrt(G * mass / radius) # Function to calculate second cosmic velocity def second_cosmic_velocity(mass, radius): return np.sqrt(2 * G * mass / radius) # Function to calculate third cosmic velocity (approximation for Solar System) def third_cosmic_velocity(v2): v_esc_sun = 617500 # Escape velocity from the Sun at Earth's orbit (m/s) return np.sqrt(v2**2 + v_esc_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plot results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.2 plt.figure(figsize=(10, 6)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Earth, Mars, and Jupiter\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\") plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"Markdown Document : This document serves as the explanation and implementation. Python Script : The script calculates and visualizes cosmic velocities for Earth, Mars, and Jupiter. Graphical Representation : The bar chart compares the velocities for different celestial bodies. Discussion : The importance of these velocities in space exploration is highlighted.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its trajectory is determined by its initial conditions (position, velocity, and altitude) and the gravitational force exerted by Earth. Understanding these trajectories is crucial for space missions, such as deploying satellites, returning objects to Earth, or planning interplanetary missions. This problem combines principles of orbital mechanics and numerical methods to analyze and simulate payload trajectories. Possible Trajectories The trajectory of a payload released near Earth depends on its initial velocity and direction relative to Earth's gravitational field. The possible trajectories are: Elliptical Orbit Occurs when the payload\u2019s velocity is less than the escape velocity. The payload orbits Earth in an elliptical path. Parabolic Trajectory Occurs when the payload\u2019s velocity equals the escape velocity. The payload follows an open parabolic path and escapes Earth's gravitational influence. Hyperbolic Trajectory Occurs when the payload\u2019s velocity exceeds the escape velocity. The payload follows an open hyperbolic path and escapes Earth's gravitational influence. Circular Orbit A special case of an elliptical orbit where the payload\u2019s velocity is precisely balanced for a circular path. Numerical Analysis To compute the path of the payload, we solve the equations of motion under Earth's gravity. The gravitational force is given by Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(m\\) is the payload's mass, - \\(r\\) is the distance between the payload and Earth's center. The equations of motion in 2D are: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] Where \\(r = \\sqrt{x^2 + y^2}\\) . We use numerical methods (e.g., the Runge-Kutta method) to solve these differential equations and compute the payload's trajectory. Python Implementation Below is a Python script to simulate and visualize the motion of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) # Initial conditions altitude = 500e3 # Altitude above Earth's surface (m) v0 = 7500 # Initial velocity (m/s) theta = 45 # Launch angle (degrees) # Convert angle to radians theta = np.radians(theta) # Initial position and velocity x0 = 0 y0 = R + altitude vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Time span for simulation t_span = (0, 10000) # 10,000 seconds t_eval = np.linspace(0, 10000, 1000) # Initial state state0 = [x0, y0, vx0, vy0] # Solve the differential equations sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, method=\"RK45\") # Extract results x = sol.y[0] y = sol.y[1] # Plot the trajectory plt.figure(figsize=(10, 6)) plt.plot(x, y, label=\"Payload Trajectory\") plt.gca().add_patch(plt.Circle((0, 0), R, color=\"blue\", label=\"Earth\")) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Trajectory of a Payload Released Near Earth\") plt.axis(\"equal\") plt.legend() plt.grid() plt.show() Graphical Representation The plot generated by the script shows the trajectory of the payload. Depending on the initial velocity and angle, the trajectory can be elliptical, parabolic, or hyperbolic. Discussion Orbital Insertion If the payload's velocity is less than the escape velocity, it enters an elliptical or circular orbit around Earth. Example: Satellite deployment. Reentry If the payload's velocity is directed toward Earth and sufficient to overcome atmospheric drag, it reenters Earth's atmosphere. Example: Returning spacecraft. Escape Scenarios If the payload's velocity equals or exceeds the escape velocity, it follows a parabolic or hyperbolic trajectory and escapes Earth's gravitational influence. Example: Interplanetary missions. Deliverables Markdown Document : This document serves as the explanation and implementation. Python Script : The script simulates and visualizes the motion of a payload released near Earth. Graphical Representation : The plot shows the payload's trajectory based on initial conditions. Discussion : The relationship between trajectories and space mission scenarios is explained.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its trajectory is determined by its initial conditions (position, velocity, and altitude) and the gravitational force exerted by Earth. Understanding these trajectories is crucial for space missions, such as deploying satellites, returning objects to Earth, or planning interplanetary missions. This problem combines principles of orbital mechanics and numerical methods to analyze and simulate payload trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#possible-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity and direction relative to Earth's gravitational field. The possible trajectories are: Elliptical Orbit Occurs when the payload\u2019s velocity is less than the escape velocity. The payload orbits Earth in an elliptical path. Parabolic Trajectory Occurs when the payload\u2019s velocity equals the escape velocity. The payload follows an open parabolic path and escapes Earth's gravitational influence. Hyperbolic Trajectory Occurs when the payload\u2019s velocity exceeds the escape velocity. The payload follows an open hyperbolic path and escapes Earth's gravitational influence. Circular Orbit A special case of an elliptical orbit where the payload\u2019s velocity is precisely balanced for a circular path.","title":"Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-analysis","text":"To compute the path of the payload, we solve the equations of motion under Earth's gravity. The gravitational force is given by Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(m\\) is the payload's mass, - \\(r\\) is the distance between the payload and Earth's center. The equations of motion in 2D are: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] Where \\(r = \\sqrt{x^2 + y^2}\\) . We use numerical methods (e.g., the Runge-Kutta method) to solve these differential equations and compute the payload's trajectory.","title":"Numerical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"Below is a Python script to simulate and visualize the motion of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) # Initial conditions altitude = 500e3 # Altitude above Earth's surface (m) v0 = 7500 # Initial velocity (m/s) theta = 45 # Launch angle (degrees) # Convert angle to radians theta = np.radians(theta) # Initial position and velocity x0 = 0 y0 = R + altitude vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Time span for simulation t_span = (0, 10000) # 10,000 seconds t_eval = np.linspace(0, 10000, 1000) # Initial state state0 = [x0, y0, vx0, vy0] # Solve the differential equations sol = solve_ivp(equations, t_span, state0, t_eval=t_eval, method=\"RK45\") # Extract results x = sol.y[0] y = sol.y[1] # Plot the trajectory plt.figure(figsize=(10, 6)) plt.plot(x, y, label=\"Payload Trajectory\") plt.gca().add_patch(plt.Circle((0, 0), R, color=\"blue\", label=\"Earth\")) plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Trajectory of a Payload Released Near Earth\") plt.axis(\"equal\") plt.legend() plt.grid() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representation","text":"The plot generated by the script shows the trajectory of the payload. Depending on the initial velocity and angle, the trajectory can be elliptical, parabolic, or hyperbolic.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-insertion","text":"If the payload's velocity is less than the escape velocity, it enters an elliptical or circular orbit around Earth. Example: Satellite deployment.","title":"Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#reentry","text":"If the payload's velocity is directed toward Earth and sufficient to overcome atmospheric drag, it reenters Earth's atmosphere. Example: Returning spacecraft.","title":"Reentry"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-scenarios","text":"If the payload's velocity equals or exceeds the escape velocity, it follows a parabolic or hyperbolic trajectory and escapes Earth's gravitational influence. Example: Interplanetary missions.","title":"Escape Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables","text":"Markdown Document : This document serves as the explanation and implementation. Python Script : The script simulates and visualizes the motion of a payload released near Earth. Graphical Representation : The plot shows the payload's trajectory based on initial conditions. Discussion : The relationship between trajectories and space mission scenarios is explained.","title":"Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}