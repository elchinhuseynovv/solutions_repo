{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion describes the motion of an object launched into the air, influenced only by gravitational acceleration. Let\u2019s derive the fundamental equations governing this motion. Horizontal displacement : $$ x(t) = v_0 \\cos(\\theta)t $$ Vertical displacement : $$ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 $$ Where: $$ v_0 = \\text{initial velocity} $$ \\[ \\theta = \\text{angle of projection} \\] \\[ g = \\text{gravitational acceleration} \\] \\[ t = \\text{time of flight} \\] The time of flight \\(Tx\\) (when the projectile returns to the same height) is given by: \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] The horizontal range \\(R\\) (total horizontal displacement at \\(y = 0\\) ) is: \\[ R = v_0 \\cos(\\theta) \\times T \\] \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that range depends on the square of the initial velocity, the sine of twice the projection angle, and gravitational acceleration. 2. Analysis of the Range The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, i.e., when \\(2\\theta = 90^\\circ\\) or \\(\\theta = 45^\\circ\\) . Increasing \\(v_0\\) increases the range quadratically. Higher gravitational acceleration \\(g\\) decreases the range. 3. Practical Applications This model is idealized \u2014 in real-world applications, factors like air resistance and uneven terrain alter the projectile\u2019s trajectory. Extensions include: Air resistance: Introduces drag, reducing range and altering the flight path. Uneven terrain: Changes the point where the projectile lands. Wind effects: Modify horizontal velocity. 4. Implementation We can visualize the range as a function of the projection angle using Python. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 50 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Angles in degrees and radians angles = np.linspace(0, 90, 500) theta = np.radians(angles) # Compute range R = (v0**2 * np.sin(2 * theta)) / g # Plot plt.figure(figsize=(8, 6)) plt.plot(angles, R) plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.show() 5. Discussion Limitations: No air resistance considered. Assumes flat terrain. Assumes constant gravitational acceleration. Extensions: Incorporate drag force. Simulate uneven landing surfaces. Model varying gravitational fields. This analysis demonstrates how varying the angle of projection impacts the range of a projectile, forming a strong basis for exploring more complex real-world motion.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion describes the motion of an object launched into the air, influenced only by gravitational acceleration. Let\u2019s derive the fundamental equations governing this motion. Horizontal displacement : $$ x(t) = v_0 \\cos(\\theta)t $$ Vertical displacement : $$ y(t) = v_0 \\sin(\\theta)t - \\frac{1}{2}gt^2 $$ Where: $$ v_0 = \\text{initial velocity} $$ \\[ \\theta = \\text{angle of projection} \\] \\[ g = \\text{gravitational acceleration} \\] \\[ t = \\text{time of flight} \\] The time of flight \\(Tx\\) (when the projectile returns to the same height) is given by: \\[ T = \\frac{2v_0 \\sin(\\theta)}{g} \\] The horizontal range \\(R\\) (total horizontal displacement at \\(y = 0\\) ) is: \\[ R = v_0 \\cos(\\theta) \\times T \\] \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that range depends on the square of the initial velocity, the sine of twice the projection angle, and gravitational acceleration.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, i.e., when \\(2\\theta = 90^\\circ\\) or \\(\\theta = 45^\\circ\\) . Increasing \\(v_0\\) increases the range quadratically. Higher gravitational acceleration \\(g\\) decreases the range.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model is idealized \u2014 in real-world applications, factors like air resistance and uneven terrain alter the projectile\u2019s trajectory. Extensions include: Air resistance: Introduces drag, reducing range and altering the flight path. Uneven terrain: Changes the point where the projectile lands. Wind effects: Modify horizontal velocity.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"We can visualize the range as a function of the projection angle using Python. import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 50 # Initial velocity in m/s g = 9.81 # Gravitational acceleration in m/s^2 # Angles in degrees and radians angles = np.linspace(0, 90, 500) theta = np.radians(angles) # Compute range R = (v0**2 * np.sin(2 * theta)) / g # Plot plt.figure(figsize=(8, 6)) plt.plot(angles, R) plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (m)') plt.title('Projectile Range vs. Angle of Projection') plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-discussion","text":"Limitations: No air resistance considered. Assumes flat terrain. Assumes constant gravitational acceleration. Extensions: Incorporate drag force. Simulate uneven landing surfaces. Model varying gravitational fields. This analysis demonstrates how varying the angle of projection impacts the range of a projectile, forming a strong basis for exploring more complex real-world motion.","title":"5. Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] where: \\(\\theta\\) = angular displacement \\(b\\) = damping coefficient \\(g\\) = gravitational acceleration \\(L\\) = length of the pendulum \\(A\\) = amplitude of the external driving force \\(\\omega\\) = frequency of the external driving force \\(t\\) = time For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] The general solution of this equation involves both homogeneous (natural) and particular (forced) solutions. The system exhibits resonance when the driving frequency \\(\\omega\\) matches the system's natural frequency \\(\\sqrt{g/L}\\) . 2. Analysis of Dynamics Key parameters influencing the system\u2019s behavior: Damping coefficient (b): Controls energy dissipation; high values lead to overdamping and slow returns to equilibrium, while low values result in underdamping and oscillations. Driving amplitude (A): Determines the intensity of the external force; larger amplitudes lead to more significant displacement and potential chaotic motion. Driving frequency ( \\(\\omega\\) ): Controls the rate of external driving; resonance occurs when \\(\\omega \\approx \\sqrt{g/L}\\) . As the parameters change, the system transitions from: Periodic oscillations: Regular and predictable motion. Quasiperiodic behavior: Motion with two incommensurate frequencies. Chaotic motion: Sensitive dependence on initial conditions, leading to unpredictable outcomes. 3. Practical Applications Energy harvesting: Devices capturing mechanical energy from oscillations. Suspension bridges: Avoiding resonance-induced destructive oscillations. Oscillating circuits: Electrical analogs of forced damped pendulums. 4. Implementation We simulate the motion of a forced damped pendulum using Python. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravitational acceleration (m/s^2) # Pendulum differential equation def forced_damped_pendulum(t, y, b, A, omega, L): theta, omega_ = y dydt = [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] return dydt # Define different scenarios to study dynamics simulations = [ {\"b\": 0.2, \"A\": 1.2, \"omega\": 2.0, \"L\": 1.0, \"label\": \"Underdamped\"}, {\"b\": 1.5, \"A\": 1.2, \"omega\": 2.0, \"L\": 1.0, \"label\": \"Overdamped\"}, {\"b\": 0.5, \"A\": 2.0, \"omega\": 2.0, \"L\": 1.0, \"label\": \"High Driving Force\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 3.0, \"L\": 1.0, \"label\": \"Higher Frequency\"}, ] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) y0 = [0.1, 0.0] results = [] for sim in simulations: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(sim[\"b\"], sim[\"A\"], sim[\"omega\"], sim[\"L\"])) results.append((sim[\"label\"], sol.t, sol.y[0], sol.y[1])) # Plot Results fig, axs = plt.subplots(len(results), 2, figsize=(12, 10)) for i, (label, t, theta, omega_) in enumerate(results): axs[i, 0].plot(t, theta) axs[i, 0].set_title(f\"{label}: \u03b8(t)\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"Angular Displacement (rad)\") axs[i, 0].grid(True) axs[i, 1].plot(theta, omega_, alpha=0.8) axs[i, 1].set_title(f\"{label}: Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show() 5. Discussion Limitations: Assumes small-angle approximation for analytical simplicity. Ignores air resistance and other real-world frictions. Extensions: Include nonlinear damping. Explore non-periodic driving forces. Visualize phase portraits and Poincar\u00e9 sections. This analysis captures the complexity of a forced damped pendulum, bridging theory and computational exploration to reveal intricate dynamics like resonance and chaos.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The forced damped pendulum is governed by the differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\sin\\theta = A\\cos(\\omega t) \\] where: \\(\\theta\\) = angular displacement \\(b\\) = damping coefficient \\(g\\) = gravitational acceleration \\(L\\) = length of the pendulum \\(A\\) = amplitude of the external driving force \\(\\omega\\) = frequency of the external driving force \\(t\\) = time For small angles ( \\(\\theta \\approx \\sin\\theta\\) ), the equation simplifies to: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\frac{g}{L}\\theta = A\\cos(\\omega t) \\] The general solution of this equation involves both homogeneous (natural) and particular (forced) solutions. The system exhibits resonance when the driving frequency \\(\\omega\\) matches the system's natural frequency \\(\\sqrt{g/L}\\) .","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Key parameters influencing the system\u2019s behavior: Damping coefficient (b): Controls energy dissipation; high values lead to overdamping and slow returns to equilibrium, while low values result in underdamping and oscillations. Driving amplitude (A): Determines the intensity of the external force; larger amplitudes lead to more significant displacement and potential chaotic motion. Driving frequency ( \\(\\omega\\) ): Controls the rate of external driving; resonance occurs when \\(\\omega \\approx \\sqrt{g/L}\\) . As the parameters change, the system transitions from: Periodic oscillations: Regular and predictable motion. Quasiperiodic behavior: Motion with two incommensurate frequencies. Chaotic motion: Sensitive dependence on initial conditions, leading to unpredictable outcomes.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy harvesting: Devices capturing mechanical energy from oscillations. Suspension bridges: Avoiding resonance-induced destructive oscillations. Oscillating circuits: Electrical analogs of forced damped pendulums.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"We simulate the motion of a forced damped pendulum using Python. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants g = 9.81 # gravitational acceleration (m/s^2) # Pendulum differential equation def forced_damped_pendulum(t, y, b, A, omega, L): theta, omega_ = y dydt = [omega_, -b * omega_ - (g / L) * np.sin(theta) + A * np.cos(omega * t)] return dydt # Define different scenarios to study dynamics simulations = [ {\"b\": 0.2, \"A\": 1.2, \"omega\": 2.0, \"L\": 1.0, \"label\": \"Underdamped\"}, {\"b\": 1.5, \"A\": 1.2, \"omega\": 2.0, \"L\": 1.0, \"label\": \"Overdamped\"}, {\"b\": 0.5, \"A\": 2.0, \"omega\": 2.0, \"L\": 1.0, \"label\": \"High Driving Force\"}, {\"b\": 0.5, \"A\": 1.2, \"omega\": 3.0, \"L\": 1.0, \"label\": \"Higher Frequency\"}, ] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) y0 = [0.1, 0.0] results = [] for sim in simulations: sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, args=(sim[\"b\"], sim[\"A\"], sim[\"omega\"], sim[\"L\"])) results.append((sim[\"label\"], sol.t, sol.y[0], sol.y[1])) # Plot Results fig, axs = plt.subplots(len(results), 2, figsize=(12, 10)) for i, (label, t, theta, omega_) in enumerate(results): axs[i, 0].plot(t, theta) axs[i, 0].set_title(f\"{label}: \u03b8(t)\") axs[i, 0].set_xlabel(\"Time (s)\") axs[i, 0].set_ylabel(\"Angular Displacement (rad)\") axs[i, 0].grid(True) axs[i, 1].plot(theta, omega_, alpha=0.8) axs[i, 1].set_title(f\"{label}: Phase Portrait\") axs[i, 1].set_xlabel(\"\u03b8 (rad)\") axs[i, 1].set_ylabel(\"\u03c9 (rad/s)\") axs[i, 1].grid(True) plt.tight_layout() plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-discussion","text":"Limitations: Assumes small-angle approximation for analytical simplicity. Ignores air resistance and other real-world frictions. Extensions: Include nonlinear damping. Explore non-periodic driving forces. Visualize phase portraits and Poincar\u00e9 sections. This analysis captures the complexity of a forced damped pendulum, bridging theory and computational exploration to reveal intricate dynamics like resonance and chaos.","title":"5. Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \u2014 Kepler's Third Law: Orbital Period and Orbital Radius Derivation of the Relationship Kepler's Third Law states that the square of the orbital period \\(T\\) of a body is proportional to the cube of its orbital radius \\(r\\) , assuming a circular orbit. This result can be derived using Newton\u2019s Law of Universal Gravitation and the concept of centripetal force. For a body of mass \\(m\\) orbiting a much larger mass \\(M\\) in a circular orbit of radius \\(r\\) : Step 1: Equating Gravitational Force to Centripetal Force \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\Rightarrow \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Here, \\(G\\) is the gravitational constant. Cancelling the mass \\(m\\) from both sides: \\[ \\frac{GM}{r^2} = \\frac{v^2}{r} \\] This gives: \\[ v^2 = \\frac{GM}{r} \\] Step 2: Expressing Orbital Velocity in Terms of Orbital Period Since \\(v = \\frac{2\\pi r}{T}\\) , we substitute into the previous equation: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{GM}{r} \\] Expanding and solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] Thus, we obtain Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\] Implications for Astronomy Determination of Planetary Masses: Observing the orbital period and radius of a moon or satellite allows astronomers to calculate the mass of the planet it orbits. Determination of Distances: In systems where distances are difficult to measure directly, Kepler's Law allows for the calculation of orbital radii based on observable periods. Satellite Design: In Earth-orbiting satellites, their altitude directly determines their orbital period, which is critical for communication, navigation, and observational purposes. Modeling of Galaxy Dynamics: Kepler's Third Law, extended with Newtonian gravity, plays a fundamental role in modeling the motion of stars around the center of galaxies. Real-World Examples The Moon's Orbit Around Earth: Orbital radius: approximately 384,400 km. Orbital period: approximately 27.3 days. Using Kepler's Law, this relationship holds true when considering Earth's mass. Planets in the Solar System: Earth's orbital radius: 1 astronomical unit (AU), orbital period: 1 year. Mars has an orbital radius of approximately 1.52 AU. Therefore, its period should be \\(T \\approx \\sqrt{1.52^3} \\approx 1.87\\) years, consistent with observations. Python Simulation and Verification import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Planetary data: Orbital radius in meters planet_data = { \"Mercury\": 5.79e10, \"Venus\": 1.08e11, \"Earth\": 1.496e11, \"Mars\": 2.28e11, \"Jupiter\": 7.78e11, \"Saturn\": 1.43e12, \"Uranus\": 2.87e12, \"Neptune\": 4.50e12 } # Extract radii radii = np.array(list(planet_data.values())) # Calculate periods using Kepler's Third Law periods = np.sqrt((4 * np.pi**2 * radii**3) / (G * M_sun)) # Calculate T^2 and R^3 r3 = radii ** 3 t2 = periods ** 2 # Logarithmic values for fitting log_r3 = np.log10(r3) log_t2 = np.log10(t2) # Linear fit in log-log space coefficients = np.polyfit(log_r3, log_t2, 1) slope, intercept = coefficients # Compute best-fit line fit_t2 = 10**(intercept + slope * log_r3) # Plot plt.figure(figsize=(8, 6)) plt.loglog(r3, t2, 'bo', label='Planet Data') plt.loglog(r3, fit_t2, 'r--', label=f'Best Fit Line (Slope = {slope:.2f})') # Annotate planet names for name, r, t in zip(planet_data.keys(), r3, t2): plt.annotate(name, (r, t), textcoords=\"offset points\", xytext=(5, 5), ha='left') plt.xlabel('Orbital Radius Cubed (m\u00b3)') plt.ylabel('Orbital Period Squared (s\u00b2)') plt.title(\"Kepler's Third Law: T\u00b2 \u221d R\u00b3 (Log-Log Scale)\") plt.grid(True, which='both', linestyle='--') plt.legend() plt.tight_layout() plt.show() Circular Orbit Visualization fig, ax = plt.subplots(figsize=(6, 6)) circle = plt.Circle((0, 0), 1, color='blue', fill=False) ax.add_patch(circle) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.set_title(\"Circular Orbit Visualization\") ax.set_xlabel(\"X-axis\") ax.set_ylabel(\"Y-axis\") ax.grid(True) plt.show() Interpretation of Results The plot of \\(T^2\\) versus \\(r^3\\) on a log-log scale produces a straight line, confirming the power-law relationship predicted by Kepler\u2019s Third Law. This consistency across the Solar System validates the universality of this relationship. Extension to Elliptical Orbits Kepler\u2019s Third Law also applies to elliptical orbits when the orbital radius is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] This generalization allows the application of the law to a broader range of celestial objects, including comets, asteroids, and exoplanets with highly elliptical orbits. Deliverables Summary Explanation of Kepler\u2019s Third Law and its derivation. Discussion of implications in astronomy. Real-world examples demonstrating the law. Python implementation verifying the relationship between \\(T^2\\) and \\(r^3\\) . Visualization of circular orbits. Extension of the discussion to elliptical orbits.","title":"Problem 1 \u2014 Kepler's Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-keplers-third-law-orbital-period-and-orbital-radius","text":"","title":"Problem 1 \u2014 Kepler's Third Law: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-the-relationship","text":"Kepler's Third Law states that the square of the orbital period \\(T\\) of a body is proportional to the cube of its orbital radius \\(r\\) , assuming a circular orbit. This result can be derived using Newton\u2019s Law of Universal Gravitation and the concept of centripetal force. For a body of mass \\(m\\) orbiting a much larger mass \\(M\\) in a circular orbit of radius \\(r\\) :","title":"Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-equating-gravitational-force-to-centripetal-force","text":"\\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\Rightarrow \\frac{GMm}{r^2} = \\frac{mv^2}{r} \\] Here, \\(G\\) is the gravitational constant. Cancelling the mass \\(m\\) from both sides: \\[ \\frac{GM}{r^2} = \\frac{v^2}{r} \\] This gives: \\[ v^2 = \\frac{GM}{r} \\]","title":"Step 1: Equating Gravitational Force to Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-expressing-orbital-velocity-in-terms-of-orbital-period","text":"Since \\(v = \\frac{2\\pi r}{T}\\) , we substitute into the previous equation: \\[ \\left( \\frac{2\\pi r}{T} \\right)^2 = \\frac{GM}{r} \\] Expanding and solving for \\(T^2\\) : \\[ T^2 = \\frac{4\\pi^2 r^3}{GM} \\] Thus, we obtain Kepler\u2019s Third Law: \\[ T^2 \\propto r^3 \\]","title":"Step 2: Expressing Orbital Velocity in Terms of Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-for-astronomy","text":"Determination of Planetary Masses: Observing the orbital period and radius of a moon or satellite allows astronomers to calculate the mass of the planet it orbits. Determination of Distances: In systems where distances are difficult to measure directly, Kepler's Law allows for the calculation of orbital radii based on observable periods. Satellite Design: In Earth-orbiting satellites, their altitude directly determines their orbital period, which is critical for communication, navigation, and observational purposes. Modeling of Galaxy Dynamics: Kepler's Third Law, extended with Newtonian gravity, plays a fundamental role in modeling the motion of stars around the center of galaxies.","title":"Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"The Moon's Orbit Around Earth: Orbital radius: approximately 384,400 km. Orbital period: approximately 27.3 days. Using Kepler's Law, this relationship holds true when considering Earth's mass. Planets in the Solar System: Earth's orbital radius: 1 astronomical unit (AU), orbital period: 1 year. Mars has an orbital radius of approximately 1.52 AU. Therefore, its period should be \\(T \\approx \\sqrt{1.52^3} \\approx 1.87\\) years, consistent with observations.","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-and-verification","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # Mass of the Sun (kg) # Planetary data: Orbital radius in meters planet_data = { \"Mercury\": 5.79e10, \"Venus\": 1.08e11, \"Earth\": 1.496e11, \"Mars\": 2.28e11, \"Jupiter\": 7.78e11, \"Saturn\": 1.43e12, \"Uranus\": 2.87e12, \"Neptune\": 4.50e12 } # Extract radii radii = np.array(list(planet_data.values())) # Calculate periods using Kepler's Third Law periods = np.sqrt((4 * np.pi**2 * radii**3) / (G * M_sun)) # Calculate T^2 and R^3 r3 = radii ** 3 t2 = periods ** 2 # Logarithmic values for fitting log_r3 = np.log10(r3) log_t2 = np.log10(t2) # Linear fit in log-log space coefficients = np.polyfit(log_r3, log_t2, 1) slope, intercept = coefficients # Compute best-fit line fit_t2 = 10**(intercept + slope * log_r3) # Plot plt.figure(figsize=(8, 6)) plt.loglog(r3, t2, 'bo', label='Planet Data') plt.loglog(r3, fit_t2, 'r--', label=f'Best Fit Line (Slope = {slope:.2f})') # Annotate planet names for name, r, t in zip(planet_data.keys(), r3, t2): plt.annotate(name, (r, t), textcoords=\"offset points\", xytext=(5, 5), ha='left') plt.xlabel('Orbital Radius Cubed (m\u00b3)') plt.ylabel('Orbital Period Squared (s\u00b2)') plt.title(\"Kepler's Third Law: T\u00b2 \u221d R\u00b3 (Log-Log Scale)\") plt.grid(True, which='both', linestyle='--') plt.legend() plt.tight_layout() plt.show()","title":"Python Simulation and Verification"},{"location":"1%20Physics/2%20Gravity/Problem_1/#circular-orbit-visualization","text":"fig, ax = plt.subplots(figsize=(6, 6)) circle = plt.Circle((0, 0), 1, color='blue', fill=False) ax.add_patch(circle) ax.set_xlim(-1.2, 1.2) ax.set_ylim(-1.2, 1.2) ax.set_aspect('equal') ax.set_title(\"Circular Orbit Visualization\") ax.set_xlabel(\"X-axis\") ax.set_ylabel(\"Y-axis\") ax.grid(True) plt.show()","title":"Circular Orbit Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#interpretation-of-results","text":"The plot of \\(T^2\\) versus \\(r^3\\) on a log-log scale produces a straight line, confirming the power-law relationship predicted by Kepler\u2019s Third Law. This consistency across the Solar System validates the universality of this relationship.","title":"Interpretation of Results"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"Kepler\u2019s Third Law also applies to elliptical orbits when the orbital radius is replaced by the semi-major axis \\(a\\) : \\[ T^2 = \\frac{4\\pi^2 a^3}{GM} \\] This generalization allows the application of the law to a broader range of celestial objects, including comets, asteroids, and exoplanets with highly elliptical orbits.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#deliverables-summary","text":"Explanation of Kepler\u2019s Third Law and its derivation. Discussion of implications in astronomy. Real-world examples demonstrating the law. Python implementation verifying the relationship between \\(T^2\\) and \\(r^3\\) . Visualization of circular orbits. Extension of the discussion to elliptical orbits.","title":"Deliverables Summary"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Problem 2: Escape Velocities and Cosmic Velocities Motivation Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel. Definitions and Physical Meaning First Cosmic Velocity (Orbital Velocity) : -- The minimum speed required for an object to achieve a stable circular orbit around a celestial body. -- Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : -- The minimum speed required for an object to escape the gravitational pull of a celestial body. -- Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : -- The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). -- Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location. Mathematical Derivation and Parameters First Cosmic Velocity Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Second Cosmic Velocity Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ Third Cosmic Velocity Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Python Implementation Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in meters, distance from Sun in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6, \"orbit_radius\": 2.279e11}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11} } # Sun's mass M_sun = 1.989e30 # kg # Functions to calculate cosmic velocities def first_cosmic_velocity(mass, radius): \"\"\" First cosmic velocity: Minimum velocity to enter orbit around the body. v1 = sqrt(G * M / R) \"\"\" return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): \"\"\" Second cosmic velocity: Minimum velocity to escape the body's gravity. v2 = sqrt(2) * v1 \"\"\" return np.sqrt(2 * G * mass / radius) def third_cosmic_velocity(v2, orbit_radius): \"\"\" Third cosmic velocity: Minimum velocity to escape the Solar System from the planet's orbit. Approximation: v3 = sqrt(v2^2 + v_sun^2) where v_sun = escape velocity from Sun at planet's orbit. \"\"\" v_sun = np.sqrt(2 * G * M_sun / orbit_radius) return np.sqrt(v2**2 + v_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2, data[\"orbit_radius\"]) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results print(\"Cosmic Velocities (in km/s):\\n\") for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plotting the results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] # km/s v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(12, 7)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Celestial Bodies (Earth, Mars, Jupiter)\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\", linestyle='--', alpha=0.7) plt.tight_layout() plt.show() Graphical Representation The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Importance in Space Exploration First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System. Deliverables Markdown Document : This document serves as the explanation and implementation. Python Script : The script calculates and visualizes cosmic velocities for Earth, Mars, and Jupiter. Graphical Representation : The bar chart compares the velocities for different celestial bodies. Discussion : The importance of these velocities in space exploration is highlighted.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocities-and-cosmic-velocities","text":"","title":"Problem 2: Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"Escape velocity is the minimum speed required for an object to break free from a celestial body's gravitational influence without further propulsion. The concept extends to cosmic velocities , which define thresholds for orbiting, escaping, and leaving a star system. These velocities are foundational for space exploration, enabling satellite launches, interplanetary missions, and even interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-and-physical-meaning","text":"First Cosmic Velocity (Orbital Velocity) : -- The minimum speed required for an object to achieve a stable circular orbit around a celestial body. -- Formula: $$ v_1 = \\sqrt{\\frac{GM}{r}} $$ Where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the celestial body, - \\(r\\) is the distance from the center of the body to the object. Second Cosmic Velocity (Escape Velocity) : -- The minimum speed required for an object to escape the gravitational pull of a celestial body. -- Formula: $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$ This is \\(\\sqrt{2}\\) times the first cosmic velocity. Third Cosmic Velocity (Interstellar Escape Velocity) : -- The minimum speed required for an object to escape the gravitational influence of a star system (e.g., the Solar System). -- Formula: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$ Where \\(v_{\\text{esc, star}}\\) is the escape velocity from the star's gravitational field at the object's location.","title":"Definitions and Physical Meaning"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivation-and-parameters","text":"","title":"Mathematical Derivation and Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Derived from the balance between centripetal force and gravitational force: $$ \\frac{mv_1^2}{r} = \\frac{GMm}{r^2} $$ Solving for \\(v_1\\) : $$ v_1 = \\sqrt{\\frac{GM}{r}} $$","title":"First Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Derived from the conservation of energy. An object must have enough kinetic energy to overcome the gravitational potential energy: $$ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} $$ Solving for \\(v_2\\) : $$ v_2 = \\sqrt{\\frac{2GM}{r}} $$","title":"Second Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Combines the escape velocity from the planet and the star system: $$ v_3 = \\sqrt{v_2^2 + v_{\\text{esc, star}}^2} $$","title":"Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-implementation","text":"Below is a Python script to calculate and visualize the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in meters, distance from Sun in meters) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6, \"orbit_radius\": 1.496e11}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6, \"orbit_radius\": 2.279e11}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7, \"orbit_radius\": 7.785e11} } # Sun's mass M_sun = 1.989e30 # kg # Functions to calculate cosmic velocities def first_cosmic_velocity(mass, radius): \"\"\" First cosmic velocity: Minimum velocity to enter orbit around the body. v1 = sqrt(G * M / R) \"\"\" return np.sqrt(G * mass / radius) def second_cosmic_velocity(mass, radius): \"\"\" Second cosmic velocity: Minimum velocity to escape the body's gravity. v2 = sqrt(2) * v1 \"\"\" return np.sqrt(2 * G * mass / radius) def third_cosmic_velocity(v2, orbit_radius): \"\"\" Third cosmic velocity: Minimum velocity to escape the Solar System from the planet's orbit. Approximation: v3 = sqrt(v2^2 + v_sun^2) where v_sun = escape velocity from Sun at planet's orbit. \"\"\" v_sun = np.sqrt(2 * G * M_sun / orbit_radius) return np.sqrt(v2**2 + v_sun**2) # Calculate velocities for each body results = {} for body, data in bodies.items(): v1 = first_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v2 = second_cosmic_velocity(data[\"mass\"], data[\"radius\"]) v3 = third_cosmic_velocity(v2, data[\"orbit_radius\"]) results[body] = {\"v1\": v1, \"v2\": v2, \"v3\": v3} # Print results print(\"Cosmic Velocities (in km/s):\\n\") for body, velocities in results.items(): print(f\"{body}:\") print(f\" First Cosmic Velocity (v1): {velocities['v1'] / 1000:.2f} km/s\") print(f\" Second Cosmic Velocity (v2): {velocities['v2'] / 1000:.2f} km/s\") print(f\" Third Cosmic Velocity (v3): {velocities['v3'] / 1000:.2f} km/s\") print() # Plotting the results labels = list(results.keys()) v1_values = [results[body][\"v1\"] / 1000 for body in labels] # km/s v2_values = [results[body][\"v2\"] / 1000 for body in labels] v3_values = [results[body][\"v3\"] / 1000 for body in labels] x = np.arange(len(labels)) width = 0.25 plt.figure(figsize=(12, 7)) plt.bar(x - width, v1_values, width, label=\"First Cosmic Velocity (v1)\") plt.bar(x, v2_values, width, label=\"Second Cosmic Velocity (v2)\") plt.bar(x + width, v3_values, width, label=\"Third Cosmic Velocity (v3)\") plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (km/s)\") plt.title(\"Cosmic Velocities for Celestial Bodies (Earth, Mars, Jupiter)\") plt.xticks(x, labels) plt.legend() plt.grid(axis=\"y\", linestyle='--', alpha=0.7) plt.tight_layout() plt.show()","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representation","text":"The bar chart generated by the script will show the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity : Essential for launching satellites into stable orbits. Example: Communication and GPS satellites. Second Cosmic Velocity : Required for missions to other planets or moons. Example: Mars rovers, lunar missions. Third Cosmic Velocity : Necessary for interstellar travel. Example: Voyager 1 and 2, which have left the Solar System.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#deliverables","text":"Markdown Document : This document serves as the explanation and implementation. Python Script : The script calculates and visualizes cosmic velocities for Earth, Mars, and Jupiter. Graphical Representation : The bar chart compares the velocities for different celestial bodies. Discussion : The importance of these velocities in space exploration is highlighted.","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Problem 3: Trajectories of a Freely Released Payload Near Earth Motivation When a payload is released from a moving rocket near Earth, its trajectory is determined by its initial conditions (position, velocity, and altitude) and the gravitational force exerted by Earth. Understanding these trajectories is crucial for space missions, such as deploying satellites, returning objects to Earth, or planning interplanetary missions. This problem combines principles of orbital mechanics and numerical methods to analyze and simulate payload trajectories. Possible Trajectories The trajectory of a payload released near Earth depends on its initial velocity and direction relative to Earth's gravitational field. The possible trajectories are: Elliptical Orbit Occurs when the payload\u2019s velocity is less than the escape velocity. The payload orbits Earth in an elliptical path. Parabolic Trajectory Occurs when the payload\u2019s velocity equals the escape velocity. The payload follows an open parabolic path and escapes Earth's gravitational influence. Hyperbolic Trajectory Occurs when the payload\u2019s velocity exceeds the escape velocity. The payload follows an open hyperbolic path and escapes Earth's gravitational influence. Circular Orbit A special case of an elliptical orbit where the payload\u2019s velocity is precisely balanced for a circular path. Numerical Analysis To compute the path of the payload, we solve the equations of motion under Earth's gravity. The gravitational force is given by Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(m\\) is the payload's mass, - \\(r\\) is the distance between the payload and Earth's center. The equations of motion in 2D are: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] Where \\(r = \\sqrt{x^2 + y^2}\\) . We use numerical methods (e.g., the Runge-Kutta method) to solve these differential equations and compute the payload's trajectory. Python Implementation Below is a Python script to simulate and visualize the motion of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) # Initial conditions altitude = 500e3 # Altitude above Earth's surface (m) v0 = 7500 # Initial velocity (m/s) theta = 45 # Launch angle (degrees) # Convert angle to radians theta = np.radians(theta) # Initial position and velocity x0 = 0 y0 = R + altitude vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event function: stop integration if payload hits Earth def hit_ground(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) return r - R # Positive above ground, zero at impact hit_ground.terminal = True hit_ground.direction = -1 # Time span for simulation t_span = (0, 20000) # Simulate up to 20,000 seconds t_eval = np.linspace(t_span[0], t_span[1], 5000) # Initial state state0 = [x0, y0, vx0, vy0] # Solve the differential equations sol = solve_ivp( equations, t_span, state0, t_eval=t_eval, method=\"RK45\", events=hit_ground ) # Extract results x = sol.y[0] y = sol.y[1] # Plot the trajectory fig, ax = plt.subplots(figsize=(10, 8)) # Plot Earth earth = plt.Circle((0, 0), R, color=\"blue\", alpha=0.5, label=\"Earth\") ax.add_artist(earth) # Plot trajectory ax.plot(x, y, label=\"Payload Trajectory\", color=\"red\") # Mark starting point ax.plot(x[0], y[0], 'go', markersize=8, label=\"Start Point\") # Mark ending point (impact or end of simulation) ax.plot(x[-1], y[-1], 'kx', markersize=8, label=\"End Point\") # Set plot properties ax.set_xlabel(\"x position (meters)\") ax.set_ylabel(\"y position (meters)\") ax.set_title(\"Trajectory of a Freely Released Payload Near Earth\") ax.axis('equal') ax.legend() ax.grid(True) plt.show() # Additional info: Did the payload crash into Earth? if sol.status == 1: print(f\"Payload impacted Earth at time {sol.t_events[0][0]:.2f} seconds.\") else: print(\"Payload did not impact Earth during simulation.\") Graphical Representation The plot generated by the script shows the trajectory of the payload. Depending on the initial velocity and angle, the trajectory can be elliptical, parabolic, or hyperbolic. Discussion Orbital Insertion If the payload's velocity is less than the escape velocity, it enters an elliptical or circular orbit around Earth. Example: Satellite deployment. Reentry If the payload's velocity is directed toward Earth and sufficient to overcome atmospheric drag, it reenters Earth's atmosphere. Example: Returning spacecraft. Escape Scenarios If the payload's velocity equals or exceeds the escape velocity, it follows a parabolic or hyperbolic trajectory and escapes Earth's gravitational influence. Example: Interplanetary missions. Deliverables Markdown Document : This document serves as the explanation and implementation. Python Script : The script simulates and visualizes the motion of a payload released near Earth. Graphical Representation : The plot shows the payload's trajectory based on initial conditions. Discussion : The relationship between trajectories and space mission scenarios is explained.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Problem 3: Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, its trajectory is determined by its initial conditions (position, velocity, and altitude) and the gravitational force exerted by Earth. Understanding these trajectories is crucial for space missions, such as deploying satellites, returning objects to Earth, or planning interplanetary missions. This problem combines principles of orbital mechanics and numerical methods to analyze and simulate payload trajectories.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#possible-trajectories","text":"The trajectory of a payload released near Earth depends on its initial velocity and direction relative to Earth's gravitational field. The possible trajectories are: Elliptical Orbit Occurs when the payload\u2019s velocity is less than the escape velocity. The payload orbits Earth in an elliptical path. Parabolic Trajectory Occurs when the payload\u2019s velocity equals the escape velocity. The payload follows an open parabolic path and escapes Earth's gravitational influence. Hyperbolic Trajectory Occurs when the payload\u2019s velocity exceeds the escape velocity. The payload follows an open hyperbolic path and escapes Earth's gravitational influence. Circular Orbit A special case of an elliptical orbit where the payload\u2019s velocity is precisely balanced for a circular path.","title":"Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-analysis","text":"To compute the path of the payload, we solve the equations of motion under Earth's gravity. The gravitational force is given by Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth's mass, - \\(m\\) is the payload's mass, - \\(r\\) is the distance between the payload and Earth's center. The equations of motion in 2D are: \\[ \\frac{d^2x}{dt^2} = -\\frac{GMx}{r^3}, \\quad \\frac{d^2y}{dt^2} = -\\frac{GMy}{r^3} \\] Where \\(r = \\sqrt{x^2 + y^2}\\) . We use numerical methods (e.g., the Runge-Kutta method) to solve these differential equations and compute the payload's trajectory.","title":"Numerical Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"Below is a Python script to simulate and visualize the motion of a payload released near Earth. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants G = 6.67430e-11 # Gravitational constant (N m^2/kg^2) M = 5.972e24 # Mass of Earth (kg) R = 6.371e6 # Radius of Earth (m) # Initial conditions altitude = 500e3 # Altitude above Earth's surface (m) v0 = 7500 # Initial velocity (m/s) theta = 45 # Launch angle (degrees) # Convert angle to radians theta = np.radians(theta) # Initial position and velocity x0 = 0 y0 = R + altitude vx0 = v0 * np.cos(theta) vy0 = v0 * np.sin(theta) # Equations of motion def equations(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) ax = -G * M * x / r**3 ay = -G * M * y / r**3 return [vx, vy, ax, ay] # Event function: stop integration if payload hits Earth def hit_ground(t, state): x, y, vx, vy = state r = np.sqrt(x**2 + y**2) return r - R # Positive above ground, zero at impact hit_ground.terminal = True hit_ground.direction = -1 # Time span for simulation t_span = (0, 20000) # Simulate up to 20,000 seconds t_eval = np.linspace(t_span[0], t_span[1], 5000) # Initial state state0 = [x0, y0, vx0, vy0] # Solve the differential equations sol = solve_ivp( equations, t_span, state0, t_eval=t_eval, method=\"RK45\", events=hit_ground ) # Extract results x = sol.y[0] y = sol.y[1] # Plot the trajectory fig, ax = plt.subplots(figsize=(10, 8)) # Plot Earth earth = plt.Circle((0, 0), R, color=\"blue\", alpha=0.5, label=\"Earth\") ax.add_artist(earth) # Plot trajectory ax.plot(x, y, label=\"Payload Trajectory\", color=\"red\") # Mark starting point ax.plot(x[0], y[0], 'go', markersize=8, label=\"Start Point\") # Mark ending point (impact or end of simulation) ax.plot(x[-1], y[-1], 'kx', markersize=8, label=\"End Point\") # Set plot properties ax.set_xlabel(\"x position (meters)\") ax.set_ylabel(\"y position (meters)\") ax.set_title(\"Trajectory of a Freely Released Payload Near Earth\") ax.axis('equal') ax.legend() ax.grid(True) plt.show() # Additional info: Did the payload crash into Earth? if sol.status == 1: print(f\"Payload impacted Earth at time {sol.t_events[0][0]:.2f} seconds.\") else: print(\"Payload did not impact Earth during simulation.\")","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_3/#graphical-representation","text":"The plot generated by the script shows the trajectory of the payload. Depending on the initial velocity and angle, the trajectory can be elliptical, parabolic, or hyperbolic.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-insertion","text":"If the payload's velocity is less than the escape velocity, it enters an elliptical or circular orbit around Earth. Example: Satellite deployment.","title":"Orbital Insertion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#reentry","text":"If the payload's velocity is directed toward Earth and sufficient to overcome atmospheric drag, it reenters Earth's atmosphere. Example: Returning spacecraft.","title":"Reentry"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-scenarios","text":"If the payload's velocity equals or exceeds the escape velocity, it follows a parabolic or hyperbolic trajectory and escapes Earth's gravitational influence. Example: Interplanetary missions.","title":"Escape Scenarios"},{"location":"1%20Physics/2%20Gravity/Problem_3/#deliverables","text":"Markdown Document : This document serves as the explanation and implementation. Python Script : The script simulates and visualizes the motion of a payload released near Earth. Graphical Representation : The plot shows the payload's trajectory based on initial conditions. Discussion : The relationship between trajectories and space mission scenarios is explained.","title":"Deliverables"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 To analyze the interference patterns formed by waves emitted from point sources placed at the vertices of a regular polygon, we can follow the steps outlined in the problem statement. Let's choose a square as our regular polygon for this analysis. Here's how we can approach the problem: Step 1: Select a Regular Polygon We choose a square with four vertices. Step 2: Position the Sources Place point wave sources at each of the four vertices of the square. Let's assume the square has a side length of \\( L \\) , and its center is at the origin \\((0, 0)\\) . The coordinates of the vertices are: - \\((L/2, L/2)\\) - \\((-L/2, L/2)\\) - \\((-L/2, -L/2)\\) - \\((L/2, -L/2)\\) Step 3: Wave Equations The wave emitted from each source can be described by the equation: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t + \\phi_i) $$ where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i\\) -th source to the point \\((x, y)\\) , and \\(\\phi_i\\) is the initial phase of the \\(i\\) -th source. Step 4: Superposition of Waves The total displacement at any point \\((x, y)\\) on the water surface is the sum of the displacements from all four sources: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{4} \\eta_i(x, y, t) $$ Step 5: Analyze Interference Patterns We need to examine the resulting displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) to identify regions of constructive and destructive interference. Step 6: Visualization We can use Python with Matplotlib to visualize the interference patterns. Here's a Python script to simulate and visualize the interference patterns: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency L = 2.0 # Side length of the square phi = 0 # Initial phase # Source positions for a square sources = [(L/2, L/2), (-L/2, L/2), (-L/2, -L/2), (L/2, -L/2)] # Create a grid for visualization x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) Z = np.zeros_like(X) # Time (assuming a snapshot at t=0 for simplicity) t = 0 # Function to calculate wave displacement from a single source def wave_displacement(x, y, x0, y0, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) return (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) # Superposition of waves from all sources for (x0, y0) in sources: Z += wave_displacement(X, Y, x0, y0, t) # Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.imshow(Z, extent=(-3, 3, -3, 3), origin='lower', cmap='viridis') plt.colorbar(label='Displacement') plt.title('Interference Pattern from Four Sources at Square Vertices') plt.xlabel('x') plt.ylabel('y') plt.show() Deliverables Markdown Document : This document includes the Python script and a detailed explanation of the interference patterns observed. Explanation : The script simulates the interference pattern from four coherent sources placed at the vertices of a square. The resulting pattern shows regions of constructive interference (bright areas) and destructive interference (dark areas). Graphical Representations : The plot generated by the script visually represents the interference pattern on the water surface. This approach provides a clear understanding of wave superposition and interference patterns using a regular polygon configuration.","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"To analyze the interference patterns formed by waves emitted from point sources placed at the vertices of a regular polygon, we can follow the steps outlined in the problem statement. Let's choose a square as our regular polygon for this analysis. Here's how we can approach the problem:","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-1-select-a-regular-polygon","text":"We choose a square with four vertices.","title":"Step 1: Select a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-2-position-the-sources","text":"Place point wave sources at each of the four vertices of the square. Let's assume the square has a side length of \\( L \\) , and its center is at the origin \\((0, 0)\\) . The coordinates of the vertices are: - \\((L/2, L/2)\\) - \\((-L/2, L/2)\\) - \\((-L/2, -L/2)\\) - \\((L/2, -L/2)\\)","title":"Step 2: Position the Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-3-wave-equations","text":"The wave emitted from each source can be described by the equation: $$ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cdot \\cos(k r_i - \\omega t + \\phi_i) $$ where \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from the \\(i\\) -th source to the point \\((x, y)\\) , and \\(\\phi_i\\) is the initial phase of the \\(i\\) -th source.","title":"Step 3: Wave Equations"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-4-superposition-of-waves","text":"The total displacement at any point \\((x, y)\\) on the water surface is the sum of the displacements from all four sources: $$ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{4} \\eta_i(x, y, t) $$","title":"Step 4: Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-5-analyze-interference-patterns","text":"We need to examine the resulting displacement \\(\\eta_{\\text{sum}}(x, y, t)\\) to identify regions of constructive and destructive interference.","title":"Step 5: Analyze Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#step-6-visualization","text":"We can use Python with Matplotlib to visualize the interference patterns. Here's a Python script to simulate and visualize the interference patterns: import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 # Amplitude wavelength = 1.0 # Wavelength k = 2 * np.pi / wavelength # Wave number omega = 2 * np.pi # Angular frequency L = 2.0 # Side length of the square phi = 0 # Initial phase # Source positions for a square sources = [(L/2, L/2), (-L/2, L/2), (-L/2, -L/2), (L/2, -L/2)] # Create a grid for visualization x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) Z = np.zeros_like(X) # Time (assuming a snapshot at t=0 for simplicity) t = 0 # Function to calculate wave displacement from a single source def wave_displacement(x, y, x0, y0, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) return (A / np.sqrt(r)) * np.cos(k * r - omega * t + phi) # Superposition of waves from all sources for (x0, y0) in sources: Z += wave_displacement(X, Y, x0, y0, t) # Plotting the interference pattern plt.figure(figsize=(10, 8)) plt.imshow(Z, extent=(-3, 3, -3, 3), origin='lower', cmap='viridis') plt.colorbar(label='Displacement') plt.title('Interference Pattern from Four Sources at Square Vertices') plt.xlabel('x') plt.ylabel('y') plt.show()","title":"Step 6: Visualization"},{"location":"1%20Physics/3%20Waves/Problem_1/#deliverables","text":"Markdown Document : This document includes the Python script and a detailed explanation of the interference patterns observed. Explanation : The script simulates the interference pattern from four coherent sources placed at the vertices of a square. The resulting pattern shows regions of constructive interference (bright areas) and destructive interference (dark areas). Graphical Representations : The plot generated by the script visually represents the interference pattern on the water surface. This approach provides a clear understanding of wave superposition and interference patterns using a regular polygon configuration.","title":"Deliverables"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force Introduction The Lorentz force governs the interaction of charged particles with electric and magnetic fields, described mathematically as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Understanding this force is essential in various fields such as particle physics, astrophysics, and engineering technologies like particle accelerators and plasma confinement systems. This simulation project extensively explores the behavior of charged particles under different electromagnetic field conditions. Theory and Background Lorentz Force The Lorentz force consists of: Electric force ( \\(q\\mathbf{E}\\) ) : Acts in the direction of the electric field, changing particle velocity magnitude. Magnetic force ( \\(q\\mathbf{v}\\times \\mathbf{B}\\) ) : Perpendicular to both particle velocity and magnetic field, modifying trajectory direction without changing speed. The dynamics of a particle under this force follow Newton's second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v}\\times \\mathbf{B}) \\] Numerical methods such as the Runge-Kutta method are employed to solve these equations. Exploration of Applications Particle Accelerators Charged particles are guided by magnetic fields, achieving high speeds through periodic electric field acceleration, essential for experiments in particle physics. Mass Spectrometry Magnetic fields differentiate particles based on their mass-to-charge ratios, enabling accurate chemical analyses and isotopic identification. Plasma Confinement Magnetic confinement in fusion reactors relies heavily on controlling particle trajectories, maintaining stable plasma conditions necessary for fusion. Simulations Comprehensive Python Implementation Here is a robust and clear Python implementation illustrating particle trajectories under varied electromagnetic conditions: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define Lorentz force equations def lorentz_force(t, state, q, m, E_func, B_func): pos, vel = state[:3], state[3:] dposdt = vel dveldt = (q/m) * (E_func(pos, t) + np.cross(vel, B_func(pos, t))) return np.concatenate([dposdt, dveldt]) # Field scenarios field_scenarios = { 'Uniform Magnetic Field': (lambda r, t: np.zeros(3), lambda r, t: np.array([0, 0, 1])), 'Combined Fields': (lambda r, t: np.array([0, 1e4, 0]), lambda r, t: np.array([0, 0, 1])), 'Crossed Fields': (lambda r, t: np.array([1e4, 0, 0]), lambda r, t: np.array([0, 0, 1])) } # Simulation parameters q, m = 1.6e-19, 9.11e-31 initial_state = np.array([0, 0, 0, 1e6, 1e6, 0]) t_span, t_eval = (0, 5e-8), np.linspace(0, 5e-8, 5000) for scenario, (E_func, B_func) in field_scenarios.items(): solution = solve_ivp(lorentz_force, t_span, initial_state, args=(q, m, E_func, B_func), t_eval=t_eval) fig = plt.figure(figsize=(12, 6)) # 3D Trajectory ax = fig.add_subplot(121, projection='3d') ax.plot(solution.y[0], solution.y[1], solution.y[2], label=scenario) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(f'3D Trajectory - {scenario}') ax.legend() # 2D Projection ax2 = fig.add_subplot(122) ax2.plot(solution.y[0], solution.y[1]) ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_title(f'2D Projection - {scenario}') ax2.grid(True) plt.tight_layout() plt.show() Parameter Exploration Examining how trajectory changes with: Electric field magnitude ( \\(\\mathbf{E}\\) ) Magnetic field strength ( \\(\\mathbf{B}\\) ) Initial velocity ( \\(\\mathbf{v}\\) ) Particle charge and mass ( \\(q,m\\) ) helps in understanding particle behavior under various real-world conditions. Visualization Circular trajectory : Observed clearly in uniform magnetic fields. Helical trajectory : Occurs with combined fields. Drift trajectory : Highlighted clearly under crossed fields, showcasing constant drift perpendicular to both fields. Visualization clearly demonstrates important physical parameters: Larmor Radius : \\(r_L = \\frac{mv}{qB}\\) Drift Velocity : \\(v_d = \\frac{E \\times B}{B^2}\\) Extensions Future simulations may incorporate: Non-uniform fields for realistic plasma containment scenarios. Time-varying fields to simulate dynamic environmental interactions. Relativistic dynamics for high-speed particle simulations. Conclusion This detailed simulation effectively illustrates the fundamental and applied aspects of the Lorentz force, providing significant insights into electromagnetic particle dynamics, supporting theoretical understanding and practical applications.","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#introduction","text":"The Lorentz force governs the interaction of charged particles with electric and magnetic fields, described mathematically as: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] Understanding this force is essential in various fields such as particle physics, astrophysics, and engineering technologies like particle accelerators and plasma confinement systems. This simulation project extensively explores the behavior of charged particles under different electromagnetic field conditions.","title":"Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theory-and-background","text":"","title":"Theory and Background"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force","text":"The Lorentz force consists of: Electric force ( \\(q\\mathbf{E}\\) ) : Acts in the direction of the electric field, changing particle velocity magnitude. Magnetic force ( \\(q\\mathbf{v}\\times \\mathbf{B}\\) ) : Perpendicular to both particle velocity and magnetic field, modifying trajectory direction without changing speed. The dynamics of a particle under this force follow Newton's second law: \\[ m \\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v}\\times \\mathbf{B}) \\] Numerical methods such as the Runge-Kutta method are employed to solve these equations.","title":"Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#exploration-of-applications","text":"","title":"Exploration of Applications"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#particle-accelerators","text":"Charged particles are guided by magnetic fields, achieving high speeds through periodic electric field acceleration, essential for experiments in particle physics.","title":"Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#mass-spectrometry","text":"Magnetic fields differentiate particles based on their mass-to-charge ratios, enabling accurate chemical analyses and isotopic identification.","title":"Mass Spectrometry"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#plasma-confinement","text":"Magnetic confinement in fusion reactors relies heavily on controlling particle trajectories, maintaining stable plasma conditions necessary for fusion.","title":"Plasma Confinement"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulations","text":"","title":"Simulations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#comprehensive-python-implementation","text":"Here is a robust and clear Python implementation illustrating particle trajectories under varied electromagnetic conditions: import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define Lorentz force equations def lorentz_force(t, state, q, m, E_func, B_func): pos, vel = state[:3], state[3:] dposdt = vel dveldt = (q/m) * (E_func(pos, t) + np.cross(vel, B_func(pos, t))) return np.concatenate([dposdt, dveldt]) # Field scenarios field_scenarios = { 'Uniform Magnetic Field': (lambda r, t: np.zeros(3), lambda r, t: np.array([0, 0, 1])), 'Combined Fields': (lambda r, t: np.array([0, 1e4, 0]), lambda r, t: np.array([0, 0, 1])), 'Crossed Fields': (lambda r, t: np.array([1e4, 0, 0]), lambda r, t: np.array([0, 0, 1])) } # Simulation parameters q, m = 1.6e-19, 9.11e-31 initial_state = np.array([0, 0, 0, 1e6, 1e6, 0]) t_span, t_eval = (0, 5e-8), np.linspace(0, 5e-8, 5000) for scenario, (E_func, B_func) in field_scenarios.items(): solution = solve_ivp(lorentz_force, t_span, initial_state, args=(q, m, E_func, B_func), t_eval=t_eval) fig = plt.figure(figsize=(12, 6)) # 3D Trajectory ax = fig.add_subplot(121, projection='3d') ax.plot(solution.y[0], solution.y[1], solution.y[2], label=scenario) ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title(f'3D Trajectory - {scenario}') ax.legend() # 2D Projection ax2 = fig.add_subplot(122) ax2.plot(solution.y[0], solution.y[1]) ax2.set_xlabel('X (m)') ax2.set_ylabel('Y (m)') ax2.set_title(f'2D Projection - {scenario}') ax2.grid(True) plt.tight_layout() plt.show()","title":"Comprehensive Python Implementation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameter-exploration","text":"Examining how trajectory changes with: Electric field magnitude ( \\(\\mathbf{E}\\) ) Magnetic field strength ( \\(\\mathbf{B}\\) ) Initial velocity ( \\(\\mathbf{v}\\) ) Particle charge and mass ( \\(q,m\\) ) helps in understanding particle behavior under various real-world conditions.","title":"Parameter Exploration"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization","text":"Circular trajectory : Observed clearly in uniform magnetic fields. Helical trajectory : Occurs with combined fields. Drift trajectory : Highlighted clearly under crossed fields, showcasing constant drift perpendicular to both fields. Visualization clearly demonstrates important physical parameters: Larmor Radius : \\(r_L = \\frac{mv}{qB}\\) Drift Velocity : \\(v_d = \\frac{E \\times B}{B^2}\\)","title":"Visualization"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Future simulations may incorporate: Non-uniform fields for realistic plasma containment scenarios. Time-varying fields to simulate dynamic environmental interactions. Relativistic dynamics for high-speed particle simulations.","title":"Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This detailed simulation effectively illustrates the fundamental and applied aspects of the Lorentz force, providing significant insights into electromagnetic particle dynamics, supporting theoretical understanding and practical applications.","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1: Equivalent Resistance Using Graph Theory Motivation Equivalent resistance calculations are fundamental in electrical engineering, crucial for understanding circuit behavior and optimizing design. Traditional methods using iterative series and parallel simplifications become cumbersome and error-prone for complex circuits. Graph theory provides an elegant, systematic, and algorithmic alternative, capable of handling intricate resistor networks with ease and precision. This approach not only enhances clarity and simplifies calculations but is also highly beneficial for automated circuit analysis and simulation software. Task Option Chosen For this task, I selected Option 2: Advanced Task \u2013 Full Implementation . This involves developing a full Python implementation capable of handling arbitrary resistor configurations, including nested series and parallel connections. Definitions and Conceptual Explanation Series connection : Two resistors in series share a single node exclusively, with no other connections branching off between them. Equivalent resistance: \\(R_{eq} = R_1 + R_2\\) Parallel connection : Two resistors in parallel share both their start and end nodes. Equivalent resistance: \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\) Graph Representation A circuit can be represented as a graph \\(G(V, E)\\) : Vertices (V) : Junction points in the circuit. Edges (E) : Resistors with resistance values as edge weights. Detailed Algorithm Description The algorithm systematically simplifies the circuit by iteratively reducing series and parallel resistor combinations until a single equivalent resistor remains: Series Reduction : Find nodes with exactly two connections (degree-2 nodes). Combine connected resistors using the series formula. Parallel Reduction : Identify nodes pairs connected by multiple edges (parallel resistors). Combine resistors using the parallel formula. Python Implementation Below is the Python implementation using the networkx library for graph operations: import networkx as nx # Series simplification function def reduce_series(G): reduced = False for node in list(G.nodes): if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if neighbors[0] != neighbors[1]: r1 = G.edges[node, neighbors[0]]['weight'] r2 = G.edges[node, neighbors[1]]['weight'] new_r = r1 + r2 G.add_edge(neighbors[0], neighbors[1], weight=new_r) G.remove_node(node) reduced = True return reduced # Parallel simplification function def reduce_parallel(G): reduced = False edges_seen = set() for u, v in list(G.edges): if (u, v) in edges_seen or (v, u) in edges_seen: continue parallel_edges = list(G.get_edge_data(u, v).items()) if len(parallel_edges) > 1: inv_r_sum = sum([1 / data['weight'] for _, data in parallel_edges]) new_r = 1 / inv_r_sum G.remove_edges_from([(u, v) for _, _ in parallel_edges]) G.add_edge(u, v, weight=new_r) reduced = True edges_seen.add((u, v)) return reduced # Calculate equivalent resistance def equivalent_resistance(G): G = G.copy() while True: series_reduced = reduce_series(G) parallel_reduced = reduce_parallel(G) if not (series_reduced or parallel_reduced): break if len(G.edges) == 1: return list(G.edges(data='weight'))[0][2] else: raise ValueError(\"Unable to simplify further.\") # Example Circuit G = nx.MultiGraph() G.add_edge('A', 'B', weight=100) G.add_edge('B', 'C', weight=200) G.add_edge('C', 'D', weight=100) G.add_edge('D', 'A', weight=200) G.add_edge('B', 'D', weight=100) R_eq = equivalent_resistance(G) print(f\"Equivalent Resistance: {R_eq} \u03a9\") Example Circuits and Analysis Simple Series : 10\u03a9 and 20\u03a9 series \u2192 \\(R_{eq} = 30\u03a9\\) Simple Parallel : 10\u03a9 and 20\u03a9 parallel \u2192 \\(R_{eq} = 6.67\u03a9\\) Nested Configuration : 10\u03a9 series with two parallel resistors (20\u03a9 each) \u2192 \\(R_{eq} = 20\u03a9\\) Graphical Representation Visualization of the circuit using NetworkX for clarity: import matplotlib.pyplot as plt pos = nx.spring_layout(G) nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=800) nx.draw_networkx_edge_labels(G, pos, edge_labels={(u,v):d['weight'] for u,v,d in G.edges(data=True)}) plt.title(\"Circuit Graph Representation\") plt.show() Algorithm Efficiency and Potential Improvements Complexity : Typically \\(O(n^2)\\) due to repeated scanning for series and parallel combinations. Improvements : Incorporate advanced data structures like Disjoint Set Union (DSU) to streamline the merging of nodes and further reduce computational complexity. Importance and Applications Graph-based circuit analysis is highly scalable and suitable for automating complex analyses in modern electrical engineering and circuit simulation software, enhancing accuracy, efficiency, and practical applicability in various engineering tasks.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1-equivalent-resistance-using-graph-theory","text":"","title":"Problem 1: Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Equivalent resistance calculations are fundamental in electrical engineering, crucial for understanding circuit behavior and optimizing design. Traditional methods using iterative series and parallel simplifications become cumbersome and error-prone for complex circuits. Graph theory provides an elegant, systematic, and algorithmic alternative, capable of handling intricate resistor networks with ease and precision. This approach not only enhances clarity and simplifies calculations but is also highly beneficial for automated circuit analysis and simulation software.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-option-chosen","text":"For this task, I selected Option 2: Advanced Task \u2013 Full Implementation . This involves developing a full Python implementation capable of handling arbitrary resistor configurations, including nested series and parallel connections.","title":"Task Option Chosen"},{"location":"1%20Physics/5%20Circuits/Problem_1/#definitions-and-conceptual-explanation","text":"Series connection : Two resistors in series share a single node exclusively, with no other connections branching off between them. Equivalent resistance: \\(R_{eq} = R_1 + R_2\\) Parallel connection : Two resistors in parallel share both their start and end nodes. Equivalent resistance: \\(\\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2}\\)","title":"Definitions and Conceptual Explanation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation","text":"A circuit can be represented as a graph \\(G(V, E)\\) : Vertices (V) : Junction points in the circuit. Edges (E) : Resistors with resistance values as edge weights.","title":"Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#detailed-algorithm-description","text":"The algorithm systematically simplifies the circuit by iteratively reducing series and parallel resistor combinations until a single equivalent resistor remains: Series Reduction : Find nodes with exactly two connections (degree-2 nodes). Combine connected resistors using the series formula. Parallel Reduction : Identify nodes pairs connected by multiple edges (parallel resistors). Combine resistors using the parallel formula.","title":"Detailed Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"Below is the Python implementation using the networkx library for graph operations: import networkx as nx # Series simplification function def reduce_series(G): reduced = False for node in list(G.nodes): if G.degree(node) == 2: neighbors = list(G.neighbors(node)) if neighbors[0] != neighbors[1]: r1 = G.edges[node, neighbors[0]]['weight'] r2 = G.edges[node, neighbors[1]]['weight'] new_r = r1 + r2 G.add_edge(neighbors[0], neighbors[1], weight=new_r) G.remove_node(node) reduced = True return reduced # Parallel simplification function def reduce_parallel(G): reduced = False edges_seen = set() for u, v in list(G.edges): if (u, v) in edges_seen or (v, u) in edges_seen: continue parallel_edges = list(G.get_edge_data(u, v).items()) if len(parallel_edges) > 1: inv_r_sum = sum([1 / data['weight'] for _, data in parallel_edges]) new_r = 1 / inv_r_sum G.remove_edges_from([(u, v) for _, _ in parallel_edges]) G.add_edge(u, v, weight=new_r) reduced = True edges_seen.add((u, v)) return reduced # Calculate equivalent resistance def equivalent_resistance(G): G = G.copy() while True: series_reduced = reduce_series(G) parallel_reduced = reduce_parallel(G) if not (series_reduced or parallel_reduced): break if len(G.edges) == 1: return list(G.edges(data='weight'))[0][2] else: raise ValueError(\"Unable to simplify further.\") # Example Circuit G = nx.MultiGraph() G.add_edge('A', 'B', weight=100) G.add_edge('B', 'C', weight=200) G.add_edge('C', 'D', weight=100) G.add_edge('D', 'A', weight=200) G.add_edge('B', 'D', weight=100) R_eq = equivalent_resistance(G) print(f\"Equivalent Resistance: {R_eq} \u03a9\")","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-circuits-and-analysis","text":"Simple Series : 10\u03a9 and 20\u03a9 series \u2192 \\(R_{eq} = 30\u03a9\\) Simple Parallel : 10\u03a9 and 20\u03a9 parallel \u2192 \\(R_{eq} = 6.67\u03a9\\) Nested Configuration : 10\u03a9 series with two parallel resistors (20\u03a9 each) \u2192 \\(R_{eq} = 20\u03a9\\)","title":"Example Circuits and Analysis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graphical-representation","text":"Visualization of the circuit using NetworkX for clarity: import matplotlib.pyplot as plt pos = nx.spring_layout(G) nx.draw(G, pos, with_labels=True, node_color='skyblue', node_size=800) nx.draw_networkx_edge_labels(G, pos, edge_labels={(u,v):d['weight'] for u,v,d in G.edges(data=True)}) plt.title(\"Circuit Graph Representation\") plt.show()","title":"Graphical Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-efficiency-and-potential-improvements","text":"Complexity : Typically \\(O(n^2)\\) due to repeated scanning for series and parallel combinations. Improvements : Incorporate advanced data structures like Disjoint Set Union (DSU) to streamline the merging of nodes and further reduce computational complexity.","title":"Algorithm Efficiency and Potential Improvements"},{"location":"1%20Physics/5%20Circuits/Problem_1/#importance-and-applications","text":"Graph-based circuit analysis is highly scalable and suitable for automating complex analyses in modern electrical engineering and circuit simulation software, enhancing accuracy, efficiency, and practical applicability in various engineering tasks.","title":"Importance and Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1: Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is one of the most important results in statistics. It asserts that, regardless of the population's distribution, the sampling distribution of the sample mean tends to a normal distribution as the sample size increases. This holds true under fairly general conditions and is a foundation for inferential statistics. Through simulation, we can empirically observe the CLT in action and better appreciate its practical implications. Task Overview In this task, we explore the Central Limit Theorem by: Generating populations with different distributions. Drawing repeated samples of various sizes. Observing the behavior of the sample means. Visualizing the results. Reflecting on real-world applications. Python Implementation import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Settings np.random.seed(42) n_samples = 10000 sample_sizes = [5, 10, 30, 50] # Distribution Generators distributions = { 'Uniform': lambda n: np.random.uniform(0, 1, n), 'Exponential': lambda n: np.random.exponential(scale=1.0, size=n), 'Binomial': lambda n: np.random.binomial(n=10, p=0.5, size=n) } # Function to simulate sampling distribution of the mean def simulate_sampling_distribution(dist_func, population_size=100000, sample_sizes=[5, 10, 30, 50]): population = dist_func(population_size) results = {} for size in sample_sizes: means = [np.mean(dist_func(size)) for _ in range(n_samples)] results[size] = means return results, population # Plotting function def plot_results(results, population, title_prefix): plt.figure(figsize=(14, 8)) plt.subplot(2, 3, 1) sns.histplot(population, kde=True, bins=50) plt.title(f\"{title_prefix} Population Distribution\") for i, size in enumerate(results): plt.subplot(2, 3, i + 2) sns.histplot(results[size], kde=True, bins=50, color='orange') plt.title(f\"Sample Size = {size}\") plt.tight_layout() plt.show() # Run simulation and visualization for each distribution for name, dist_func in distributions.items(): results, population = simulate_sampling_distribution(dist_func, sample_sizes=sample_sizes) plot_results(results, population, name) Observations & Discussion Uniform Distribution : Initially flat and non-normal, the sampling distributions converge quickly to a bell-shaped curve. Exponential Distribution : Highly skewed to begin with, but sample means approach normality as size increases. Binomial Distribution : Discrete distribution that becomes smooth and normal-shaped with larger samples. Parameter Exploration Effect of Sample Size : As the sample size increases, the variability of the sample means decreases and the shape converges toward normality. Population Variance Impact : Larger population variance leads to a wider spread in the sampling distribution, even after normalization. Practical Applications Quality Control : Detecting deviations from the mean product weight. Polling and Surveys : Estimating opinions or characteristics of large populations. Finance : Risk estimation, average returns modeling, and confidence intervals. Deliverables Python script for CLT simulation. Histograms showing sample mean convergence. Discussion connecting the observed patterns to theoretical expectations of the CLT. This simulation reinforces the Central Limit Theorem's powerful role in statistics, demonstrating that even non-normal data leads to a normally distributed mean under sufficient sample sizes.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1-exploring-the-central-limit-theorem-through-simulations","text":"","title":"Problem 1: Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is one of the most important results in statistics. It asserts that, regardless of the population's distribution, the sampling distribution of the sample mean tends to a normal distribution as the sample size increases. This holds true under fairly general conditions and is a foundation for inferential statistics. Through simulation, we can empirically observe the CLT in action and better appreciate its practical implications.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-overview","text":"In this task, we explore the Central Limit Theorem by: Generating populations with different distributions. Drawing repeated samples of various sizes. Observing the behavior of the sample means. Visualizing the results. Reflecting on real-world applications.","title":"Task Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Settings np.random.seed(42) n_samples = 10000 sample_sizes = [5, 10, 30, 50] # Distribution Generators distributions = { 'Uniform': lambda n: np.random.uniform(0, 1, n), 'Exponential': lambda n: np.random.exponential(scale=1.0, size=n), 'Binomial': lambda n: np.random.binomial(n=10, p=0.5, size=n) } # Function to simulate sampling distribution of the mean def simulate_sampling_distribution(dist_func, population_size=100000, sample_sizes=[5, 10, 30, 50]): population = dist_func(population_size) results = {} for size in sample_sizes: means = [np.mean(dist_func(size)) for _ in range(n_samples)] results[size] = means return results, population # Plotting function def plot_results(results, population, title_prefix): plt.figure(figsize=(14, 8)) plt.subplot(2, 3, 1) sns.histplot(population, kde=True, bins=50) plt.title(f\"{title_prefix} Population Distribution\") for i, size in enumerate(results): plt.subplot(2, 3, i + 2) sns.histplot(results[size], kde=True, bins=50, color='orange') plt.title(f\"Sample Size = {size}\") plt.tight_layout() plt.show() # Run simulation and visualization for each distribution for name, dist_func in distributions.items(): results, population = simulate_sampling_distribution(dist_func, sample_sizes=sample_sizes) plot_results(results, population, name)","title":"Python Implementation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#observations-discussion","text":"Uniform Distribution : Initially flat and non-normal, the sampling distributions converge quickly to a bell-shaped curve. Exponential Distribution : Highly skewed to begin with, but sample means approach normality as size increases. Binomial Distribution : Discrete distribution that becomes smooth and normal-shaped with larger samples.","title":"Observations &amp; Discussion"},{"location":"1%20Physics/6%20Statistics/Problem_1/#parameter-exploration","text":"Effect of Sample Size : As the sample size increases, the variability of the sample means decreases and the shape converges toward normality. Population Variance Impact : Larger population variance leads to a wider spread in the sampling distribution, even after normalization.","title":"Parameter Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_1/#practical-applications","text":"Quality Control : Detecting deviations from the mean product weight. Polling and Surveys : Estimating opinions or characteristics of large populations. Finance : Risk estimation, average returns modeling, and confidence intervals.","title":"Practical Applications"},{"location":"1%20Physics/6%20Statistics/Problem_1/#deliverables","text":"Python script for CLT simulation. Histograms showing sample mean convergence. Discussion connecting the observed patterns to theoretical expectations of the CLT. This simulation reinforces the Central Limit Theorem's powerful role in statistics, demonstrating that even non-normal data leads to a normally distributed mean under sufficient sample sizes.","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem: Estimating \\(\\pi\\) Using Simulations PART 1: Estimating \\(\\pi\\) Using a Circle 1. Theoretical Foundation To estimate \\( \\pi \\) , we can use the Monte Carlo method with a unit circle inscribed in a square. The idea is to generate random points inside the square and count how many fall inside the circle. Since the area of a unit circle is \\(\\pi r^2 = \\pi\\) and the area of the square is \\(4\\) (since its sides go from -1 to 1), the ratio of the circle\u2019s area to the square\u2019s area is \\(\\pi / 4\\) . Therefore, we can estimate \\(\\pi\\) as: \\[ \\pi \\approx 4 \\times \\frac{\\text{points inside circle}}{\\text{total points}} \\] 2. Simulation import numpy as np import matplotlib.pyplot as plt # Monte Carlo simulation to estimate pi def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points return pi_estimate, x, y, inside_circle # Run simulation n_points = 10000 pi_est, x_vals, y_vals, in_circle = estimate_pi_circle(n_points) print(f\"Estimated \u03c0: {pi_est}\") 3. Visualization plt.figure(figsize=(6, 6)) plt.scatter(x_vals[in_circle], y_vals[in_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x_vals[~in_circle], y_vals[~in_circle], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f\"Estimating \u03c0 Using Monte Carlo\\nEstimated \u03c0 \u2248 {pi_est:.5f}\") plt.legend() plt.show() 4. Analysis As the number of random points increases, the estimate becomes more accurate. The convergence is slow but consistent; doubling the points does not halve the error. This method demonstrates the strength of probabilistic approximation, but also its computational limitations. PART 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle 1. Theoretical Foundation Buffon\u2019s Needle is a classic probability method for estimating \\(\\pi\\) . It involves dropping a needle of length \\(L\\) on a plane with parallel lines spaced \\(t\\) units apart. The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi t} \\quad \\text{(when } L \\leq t) \\] Rearranged to estimate \\( \\pi \\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{t \\cdot C} \\] Where: \\(L\\) = needle length \\(t\\) = distance between lines \\(N\\) = number of throws \\(C\\) = number of crossings 2. Simulation import numpy as np def estimate_pi_buffon(n_throws, L=1.0, t=2.0): x = np.random.uniform(0, t/2, n_throws) # distance to closest line theta = np.random.uniform(0, np.pi/2, n_throws) # angle with horizontal crosses = x <= (L/2) * np.sin(theta) C = np.sum(crosses) if C == 0: return None pi_estimate = (2 * L * n_throws) / (t * C) return pi_estimate, x, theta, crosses # Run simulation n_throws = 10000 pi_buffon, x_vals, theta_vals, cross_flags = estimate_pi_buffon(n_throws) print(f\"Estimated \u03c0 via Buffon\u2019s Needle: {pi_buffon:.5f}\") 3. Visualization import matplotlib.pyplot as plt lines_y = np.arange(0, 10, 2) plt.figure(figsize=(6, 6)) for y in lines_y: plt.axhline(y, color='gray', linestyle='--') for i in range(200): y_center = np.random.uniform(0, 10) theta = theta_vals[i] x_start = 5 - (np.cos(theta)/2) x_end = 5 + (np.cos(theta)/2) y_start = y_center - (np.sin(theta)/2) y_end = y_center + (np.sin(theta)/2) color = 'red' if cross_flags[i] else 'blue' plt.plot([x_start, x_end], [y_start, y_end], color=color) plt.title(\"Buffon\u2019s Needle Simulation\") plt.xlim(4, 6) plt.ylim(0, 10) plt.show() 4. Analysis Buffon\u2019s Needle is elegant but has a high variance , meaning estimates can fluctuate. Requires a large number of trials for accuracy. Useful in demonstrating connections between geometry, probability, and estimation . Deliverables Python scripts for both methods. Plots: circle hit/miss and Buffon\u2019s needle visuals. Markdown write-up including: Theoretical foundations Visual and numerical results Accuracy and convergence comparisons Hints & Resources Use NumPy for randomness and Matplotlib for plotting. Buffon\u2019s method requires careful simulation of geometry (angle + distance). Monte Carlo circle method is simpler and converges more consistently. Run multiple trials or increase iterations to explore accuracy. Summary Both methods estimate \\(\\pi\\) through randomness: - The circle-based Monte Carlo method is easier and more consistent. - Buffon\u2019s Needle is more mathematically elegant but converges slowly. Each illustrates important statistical and computational ideas through simulation.","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-estimating-pi-using-simulations","text":"","title":"Problem: Estimating \\(\\pi\\) Using Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"PART 1: Estimating \\(\\pi\\) Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"To estimate \\( \\pi \\) , we can use the Monte Carlo method with a unit circle inscribed in a square. The idea is to generate random points inside the square and count how many fall inside the circle. Since the area of a unit circle is \\(\\pi r^2 = \\pi\\) and the area of the square is \\(4\\) (since its sides go from -1 to 1), the ratio of the circle\u2019s area to the square\u2019s area is \\(\\pi / 4\\) . Therefore, we can estimate \\(\\pi\\) as: \\[ \\pi \\approx 4 \\times \\frac{\\text{points inside circle}}{\\text{total points}} \\]","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Monte Carlo simulation to estimate pi def estimate_pi_circle(n_points): x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) inside_circle = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / n_points return pi_estimate, x, y, inside_circle # Run simulation n_points = 10000 pi_est, x_vals, y_vals, in_circle = estimate_pi_circle(n_points) print(f\"Estimated \u03c0: {pi_est}\")","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"plt.figure(figsize=(6, 6)) plt.scatter(x_vals[in_circle], y_vals[in_circle], color='blue', s=1, label='Inside Circle') plt.scatter(x_vals[~in_circle], y_vals[~in_circle], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal') plt.title(f\"Estimating \u03c0 Using Monte Carlo\\nEstimated \u03c0 \u2248 {pi_est:.5f}\") plt.legend() plt.show()","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"As the number of random points increases, the estimate becomes more accurate. The convergence is slow but consistent; doubling the points does not halve the error. This method demonstrates the strength of probabilistic approximation, but also its computational limitations.","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"PART 2: Estimating \\(\\pi\\) Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"Buffon\u2019s Needle is a classic probability method for estimating \\(\\pi\\) . It involves dropping a needle of length \\(L\\) on a plane with parallel lines spaced \\(t\\) units apart. The probability that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi t} \\quad \\text{(when } L \\leq t) \\] Rearranged to estimate \\( \\pi \\) : \\[ \\pi \\approx \\frac{2L \\cdot N}{t \\cdot C} \\] Where: \\(L\\) = needle length \\(t\\) = distance between lines \\(N\\) = number of throws \\(C\\) = number of crossings","title":"1. Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"import numpy as np def estimate_pi_buffon(n_throws, L=1.0, t=2.0): x = np.random.uniform(0, t/2, n_throws) # distance to closest line theta = np.random.uniform(0, np.pi/2, n_throws) # angle with horizontal crosses = x <= (L/2) * np.sin(theta) C = np.sum(crosses) if C == 0: return None pi_estimate = (2 * L * n_throws) / (t * C) return pi_estimate, x, theta, crosses # Run simulation n_throws = 10000 pi_buffon, x_vals, theta_vals, cross_flags = estimate_pi_buffon(n_throws) print(f\"Estimated \u03c0 via Buffon\u2019s Needle: {pi_buffon:.5f}\")","title":"2. Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"import matplotlib.pyplot as plt lines_y = np.arange(0, 10, 2) plt.figure(figsize=(6, 6)) for y in lines_y: plt.axhline(y, color='gray', linestyle='--') for i in range(200): y_center = np.random.uniform(0, 10) theta = theta_vals[i] x_start = 5 - (np.cos(theta)/2) x_end = 5 + (np.cos(theta)/2) y_start = y_center - (np.sin(theta)/2) y_end = y_center + (np.sin(theta)/2) color = 'red' if cross_flags[i] else 'blue' plt.plot([x_start, x_end], [y_start, y_end], color=color) plt.title(\"Buffon\u2019s Needle Simulation\") plt.xlim(4, 6) plt.ylim(0, 10) plt.show()","title":"3. Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Buffon\u2019s Needle is elegant but has a high variance , meaning estimates can fluctuate. Requires a large number of trials for accuracy. Useful in demonstrating connections between geometry, probability, and estimation .","title":"4. Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#deliverables","text":"Python scripts for both methods. Plots: circle hit/miss and Buffon\u2019s needle visuals. Markdown write-up including: Theoretical foundations Visual and numerical results Accuracy and convergence comparisons","title":"Deliverables"},{"location":"1%20Physics/6%20Statistics/Problem_2/#hints-resources","text":"Use NumPy for randomness and Matplotlib for plotting. Buffon\u2019s method requires careful simulation of geometry (angle + distance). Monte Carlo circle method is simpler and converges more consistently. Run multiple trials or increase iterations to explore accuracy.","title":"Hints &amp; Resources"},{"location":"1%20Physics/6%20Statistics/Problem_2/#summary","text":"Both methods estimate \\(\\pi\\) through randomness: - The circle-based Monte Carlo method is easier and more consistent. - Buffon\u2019s Needle is more mathematically elegant but converges slowly. Each illustrates important statistical and computational ideas through simulation.","title":"Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity ( \\(g\\) ) is a fundamental physical constant that affects a wide variety of phenomena. Accurate measurement of \\(g\\) is essential in understanding gravitational interactions, engineering applications, and experimental physics. One reliable method to determine \\(g\\) is through the oscillation period of a simple pendulum. The relationship between the pendulum's period and its length allows us to estimate \\(g\\) while also analyzing the impact of measurement uncertainties. Task Measure the local gravitational acceleration \\(g\\) using a pendulum setup. Carefully analyze uncertainties to understand the precision of your measurements and how experimental limitations influence the final result. Procedure 1. Materials A string (1 or 1.5 meters long). A small mass (e.g., a metal washer, keychain, or small bag). Stopwatch (or smartphone timer). Ruler or measuring tape. 2. Setup Securely attach the weight to the end of the string and fix the other end to a stable point. Measure the length \\(L\\) of the pendulum from the suspension point to the center of the mass. Record the ruler resolution \\(\\Delta L\\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\] 3. Data Collection Displace the pendulum by a small angle (<15\u00b0) and release. Measure the time for 10 oscillations ( \\(T_{10}\\) ). Repeat this 10 times. Compute the average \\(\\overline{T_{10}}\\) and standard deviation \\(\\sigma_{T}\\) . Determine the uncertainty in the mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 \\] Calculations 1. Calculate the Period \\[ T = \\frac{\\overline{T_{10}}}{10} \\quad \\text{and} \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\] 2. Determine g \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 3. Propagate Uncertainties \\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(\\frac{2 \\Delta T}{T}\\right)^2 } \\] Python Code for Analysis import numpy as np # Sample data (user should replace with actual values) L = 1.00 # length of pendulum in meters ruler_resolution = 0.01 # in meters T10_measurements = [20.1, 20.3, 20.2, 20.0, 20.4, 20.2, 20.3, 20.1, 20.2, 20.3] # in seconds # Calculations n = len(T10_measurements) T10_array = np.array(T10_measurements) T10_mean = np.mean(T10_array) sigma_T10 = np.std(T10_array, ddof=1) Delta_T10 = sigma_T10 / np.sqrt(n) T = T10_mean / 10 Delta_T = Delta_T10 / 10 Delta_L = ruler_resolution / 2 g = (4 * np.pi**2 * L) / (T**2) Delta_g = g * np.sqrt((Delta_L / L)**2 + ((2 * Delta_T) / T)**2) # Output print(f\"Mean T10: {T10_mean:.4f} s\") print(f\"Standard deviation (\u03c3_T10): {sigma_T10:.4f} s\") print(f\"Period T: {T:.4f} s\") print(f\"g = {g:.4f} m/s\u00b2\") print(f\"Uncertainty in g (\u0394g): {Delta_g:.4f} m/s\u00b2\") import matplotlib.pyplot as plt # Plot individual T10 measurements plt.figure(figsize=(8, 5)) plt.plot(T10_measurements, marker='o', linestyle='-', color='blue', label='T\u2081\u2080 Measurements') plt.axhline(T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.title(\"Measured Times for 10 Oscillations (T\u2081\u2080)\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (seconds)\") plt.grid(True) plt.legend() plt.tight_layout() # Show plot plt.show() # Optionally save plot plt.savefig(\"pendulum_T10_measurements.png\", dpi=300) Analysis Compare your measured \\(g\\) with the accepted standard value ( \\(9.81\\, m/s^2\\) ). Discuss: The effect of measurement resolution on \\(\\Delta L\\) . Timing variability and its impact on \\(\\Delta T\\) . Experimental assumptions and sources of error (e.g., air resistance, angle, stopwatch lag). Deliverables A Markdown table including: Measured \\(L\\) , \\(\\Delta L\\) , 10 values of \\(T_{10}\\) , \\(\\overline{T_{10}}\\) , \\(\\sigma_T\\) , and \\(\\Delta T\\) . Calculated values of \\(g\\) and \\(\\Delta g\\) . A discussion on: Sources of uncertainty. Comparison to standard gravity. How measurement practices affect result reliability.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1-measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Problem 1: Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity ( \\(g\\) ) is a fundamental physical constant that affects a wide variety of phenomena. Accurate measurement of \\(g\\) is essential in understanding gravitational interactions, engineering applications, and experimental physics. One reliable method to determine \\(g\\) is through the oscillation period of a simple pendulum. The relationship between the pendulum's period and its length allows us to estimate \\(g\\) while also analyzing the impact of measurement uncertainties.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the local gravitational acceleration \\(g\\) using a pendulum setup. Carefully analyze uncertainties to understand the precision of your measurements and how experimental limitations influence the final result.","title":"Task"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (1 or 1.5 meters long). A small mass (e.g., a metal washer, keychain, or small bag). Stopwatch (or smartphone timer). Ruler or measuring tape.","title":"1. Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Securely attach the weight to the end of the string and fix the other end to a stable point. Measure the length \\(L\\) of the pendulum from the suspension point to the center of the mass. Record the ruler resolution \\(\\Delta L\\) as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\]","title":"2. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Displace the pendulum by a small angle (<15\u00b0) and release. Measure the time for 10 oscillations ( \\(T_{10}\\) ). Repeat this 10 times. Compute the average \\(\\overline{T_{10}}\\) and standard deviation \\(\\sigma_{T}\\) . Determine the uncertainty in the mean time: \\[ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 \\]","title":"3. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"\\[ T = \\frac{\\overline{T_{10}}}{10} \\quad \\text{and} \\quad \\Delta T = \\frac{\\Delta T_{10}}{10} \\]","title":"1. Calculate the Period"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Determine g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"\\[ \\Delta g = g \\sqrt{ \\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(\\frac{2 \\Delta T}{T}\\right)^2 } \\]","title":"3. Propagate Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-code-for-analysis","text":"import numpy as np # Sample data (user should replace with actual values) L = 1.00 # length of pendulum in meters ruler_resolution = 0.01 # in meters T10_measurements = [20.1, 20.3, 20.2, 20.0, 20.4, 20.2, 20.3, 20.1, 20.2, 20.3] # in seconds # Calculations n = len(T10_measurements) T10_array = np.array(T10_measurements) T10_mean = np.mean(T10_array) sigma_T10 = np.std(T10_array, ddof=1) Delta_T10 = sigma_T10 / np.sqrt(n) T = T10_mean / 10 Delta_T = Delta_T10 / 10 Delta_L = ruler_resolution / 2 g = (4 * np.pi**2 * L) / (T**2) Delta_g = g * np.sqrt((Delta_L / L)**2 + ((2 * Delta_T) / T)**2) # Output print(f\"Mean T10: {T10_mean:.4f} s\") print(f\"Standard deviation (\u03c3_T10): {sigma_T10:.4f} s\") print(f\"Period T: {T:.4f} s\") print(f\"g = {g:.4f} m/s\u00b2\") print(f\"Uncertainty in g (\u0394g): {Delta_g:.4f} m/s\u00b2\") import matplotlib.pyplot as plt # Plot individual T10 measurements plt.figure(figsize=(8, 5)) plt.plot(T10_measurements, marker='o', linestyle='-', color='blue', label='T\u2081\u2080 Measurements') plt.axhline(T10_mean, color='red', linestyle='--', label=f'Mean = {T10_mean:.2f} s') plt.title(\"Measured Times for 10 Oscillations (T\u2081\u2080)\") plt.xlabel(\"Trial Number\") plt.ylabel(\"Time (seconds)\") plt.grid(True) plt.legend() plt.tight_layout() # Show plot plt.show() # Optionally save plot plt.savefig(\"pendulum_T10_measurements.png\", dpi=300)","title":"Python Code for Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"Compare your measured \\(g\\) with the accepted standard value ( \\(9.81\\, m/s^2\\) ). Discuss: The effect of measurement resolution on \\(\\Delta L\\) . Timing variability and its impact on \\(\\Delta T\\) . Experimental assumptions and sources of error (e.g., air resistance, angle, stopwatch lag).","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"A Markdown table including: Measured \\(L\\) , \\(\\Delta L\\) , 10 values of \\(T_{10}\\) , \\(\\overline{T_{10}}\\) , \\(\\sigma_T\\) , and \\(\\Delta T\\) . Calculated values of \\(g\\) and \\(\\Delta g\\) . A discussion on: Sources of uncertainty. Comparison to standard gravity. How measurement practices affect result reliability.","title":"Deliverables"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}